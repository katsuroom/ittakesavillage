This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-02T18:13:11.463Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
client/assets.js
client/global.js
client/index.html
client/index.js
client/js/socket.io.js
client/scenes/HelpModal.js
client/scenes/SceneCredits.js
client/scenes/SceneGame.js
client/scenes/SceneLobby.js
client/scenes/SceneMenu.js
client/scenes/SceneWin.js
client/src/Animation.js
client/src/Button.js
client/src/DayNotification.js
client/src/ItemStack.js
client/src/Notification.js
client/src/NotificationArrival.js
client/src/NotificationEvent.js
client/src/NotificationFlee.js
client/src/NotificationQuest.js
client/src/NotificationSeason.js
client/src/SceneManager.js
client/src/TextField.js
client/src/ToolTip.js
client/styles.css
map/map.tmx
map/menu.tmx
map/roguelike.tsx
map/tinytown.tsx
Procfile
README.md
server/assets/text/names-female.txt
server/assets/text/names-male.txt
server/db.js
server/global.js
server/package.json
server/src/Event.js
server/src/Facility.js
server/src/Farmland.js
server/src/Food.js
server/src/Game.js
server/src/Interactable.js
server/src/Item.js
server/src/ItemStack.js
server/src/Material.js
server/src/Player.js
server/src/Quest.js
server/src/RandomTable.js
server/src/Season.js
server/src/Seed.js
server/src/ShopItem.js
server/src/Tree.js
server/src/Villager.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
server/node_modules/
node_modules/

================
File: client/assets.js
================
function loadImage(src)
{
    let newImage = new Image();
    newImage.onload = function() {return;}
    newImage.src = src;
    return newImage;
}

function loadFont(name, src)
{
    let newFont = new FontFace(name, src);
    newFont.load().then(function(font){
        document.fonts.add(font);
    });

    return newFont;
}

export const img = {
    menu:               loadImage("assets/art/menu.png"),
    lobby:              loadImage("assets/art/lobby.png"),
    background:         loadImage("assets/art/map.png"),
    villagerHair:       loadImage("assets/art/villager_hair.png"),
    villagerHeadarms:   loadImage("assets/art/villager_headarms.png"),
    villagerShirt:      loadImage("assets/art/villager_shirt.png"),
    facilityWater:      loadImage("assets/art/facility_water.png"),
    facilityEducation:  loadImage("assets/art/facility_education.png"),
    facilityHousing:    loadImage("assets/art/facility_housing.png"),
    powerOff:           loadImage("assets/art/power_off.png"),
    powerOn:            loadImage("assets/art/power_on.png"),
    farmland:           loadImage("assets/art/farmland.png"),
    farmlandLocked:     loadImage("assets/art/farmland_locked.png"),
    farmlandFertilized: loadImage("assets/art/farmland_fertilized.png"),
    plant:              loadImage("assets/art/plant.png"),
    treeBare:           loadImage("assets/art/tree_bare.png"),
    treeRipe:           loadImage("assets/art/tree_ripe.png"),
    treeFertilized:     loadImage("assets/art/tree_fertilized.png"),
    treeStump:          loadImage("assets/art/tree_stump.png"),
    cloudShadows:       loadImage("assets/art/cloud_shadows.png"),
    puddles:            loadImage("assets/art/puddles.png"),
    rain0:              loadImage("assets/art/rain0.png"),
    rain1:              loadImage("assets/art/rain1.png"),
    heart:              loadImage("assets/art/heart.png"),
    inventory:          loadImage("assets/art/inventory.png"), // size is 25px x 25px

    // items
    "cucumber":         loadImage("assets/art/cucumber.png"),
    "cucumber_seed":    loadImage("assets/art/cucumber_seed.png"),
    "tomato":           loadImage("assets/art/tomato.png"),
    "tomato_seed":      loadImage("assets/art/tomato_seed.png"),
    "potato":           loadImage("assets/art/potato.png"),
    "potato_seed":      loadImage("assets/art/potato_seed.png"),
    "carrot":           loadImage("assets/art/carrot.png"),
    "carrot_seed":      loadImage("assets/art/carrot_seed.png"),
    "apple":            loadImage("assets/art/apple.png"),
    "wood":             loadImage("assets/art/wood.png"),
    "brick":            loadImage("assets/art/brick.png"),
    "steel":            loadImage("assets/art/steel.png"),

    // events
    "event_black_friday":   loadImage("assets/art/event_black_friday.png"),
    "event_cloudy_day":     loadImage("assets/art/event_cloudy_day.png"),
    "event_death":          loadImage("assets/art/event_death.png"),
    "event_disease":        loadImage("assets/art/event_disease.png"),
    "event_drought":        loadImage("assets/art/event_drought.png"),
    "event_flood":          loadImage("assets/art/event_flood.png"),
    "event_free_cake":      loadImage("assets/art/event_free_cake.png"),
    "event_harvest":        loadImage("assets/art/event_harvest.png"),
    "event_heat_stroke":    loadImage("assets/art/event_heat_stroke.png"),
    "event_rainy_day":      loadImage("assets/art/event_rainy_day.png"),
    "event_summer_day":     loadImage("assets/art/event_summer_day.png")
};

// load power frames
for(let i = 1; i <= 26; i++)
    img["power_on_" + i] = loadImage("assets/art/power_on/power_on_" + i + ".png");


export const audio = {
    bgm: new Audio("assets/audio/bgm.mp3"),
    notification: new Audio("assets/audio/notification.ogg"),
    click: new Audio("assets/audio/click.ogg")
};

audio.bgm.loop = true;
audio.bgm.volume = 0.25;
audio.notification.volume = 0.25;
audio.click.volume = 0.5;

const font = {
    miniSquare:         loadFont("Kenney Mini Square", "url(assets/fonts/Kenney%20Mini%20Square.ttf)"),
    fsregulate:         loadFont("fs regulate", "url(assets/fonts/fs-regulate.ttf)"),
    otonnokizakaMono:         loadFont("o mono", "url(assets/fonts/otonokizaka-mono-ii.ttf)")
}

================
File: client/global.js
================
export const socket = io();

export const canvas = document.getElementById("canvas");
export const ctx = canvas.getContext("2d", { willReadFrequently: true });

export const SCALE = 2;

import {img} from "../assets.js";


// mouse events ////////////////////////////////////////////////////////////////

export let mouse = {x: 0, y: 0};

canvas.addEventListener("mousemove", (e) => {
    mouse.x = e.offsetX;
    mouse.y = e.offsetY;
});


// game variables ////////////////////////////////////////////////////////////////

export let players = [];
export let rolesPresent = {};
export let npcPresent = {};

export let playerName = "";
export let role = "";
export let roomId = "";
export let socketId = "";
export let inventory = [];             // array of ItemStack objects in inventory

export let isHost = false;


// functions ////////////////////////////////////////////////////////////////

export function buttonClick(button)
{
    if(!button.enabled) return false;

    return mouseInteract(button);
}

export function mouseInteract(obj)
{
    if(mouse.x < obj.interactBox.x * SCALE) return false;
    if(mouse.x > obj.interactBox.x * SCALE + obj.interactBox.width * SCALE) return false;
    if(mouse.y < obj.interactBox.y * SCALE) return false;
    if(mouse.y > obj.interactBox.y * SCALE + obj.interactBox.height * SCALE) return false;
    return true;
}

export function drawToolTipIcon(toolTip){
    ctx.beginPath();
    ctx.fillStyle = "#ffffff";
    ctx.moveTo((toolTip.interactBox.x) * SCALE, toolTip.interactBox.y * SCALE);
    ctx.arc((toolTip.interactBox.x) * SCALE, toolTip.interactBox.y * SCALE, toolTip.interactBox.radius * SCALE, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.fill();
}

export function drawButton(button)
{
    ctx.fillStyle = button.colorA;
    ctx.fillRect(
        button.interactBox.x * SCALE,
        button.interactBox.y * SCALE,
        button.interactBox.width * SCALE,
        button.interactBox.height * SCALE);

    ctx.fillStyle = button.colorB;
    ctx.fillRect(
        (button.interactBox.x + 1) * SCALE,
        (button.interactBox.y + 1) * SCALE,
        (button.interactBox.width - 2) * SCALE,
        (button.interactBox.height - 2) * SCALE);

    ctx.fillStyle = button.colorA;
    ctx.fillRect(
        (button.interactBox.x + 3) * SCALE,
        (button.interactBox.y + 3) * SCALE,
        (button.interactBox.width - 6) * SCALE,
        (button.interactBox.height - 6) * SCALE);

    ctx.save();

    ctx.font = "24px Kenney Mini Square";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    if(typeof button.text === "object"){
        ctx.drawImage(button.text,
            (button.interactBox.x + button.interactBox.width / 4) * SCALE,
            (button.interactBox.y + button.interactBox.height / 4) * SCALE);
    }else{
        ctx.fillText(button.text,
            (button.interactBox.x + button.interactBox.width / 2) * SCALE,
            (button.interactBox.y + button.interactBox.height / 2 - 3) * SCALE);
    }

    if(button.enabled && mouseInteract(button))
    {
        ctx.globalAlpha = 0.3;
        ctx.fillRect(
            button.interactBox.x * SCALE,
            button.interactBox.y * SCALE,
            button.interactBox.width * SCALE,
            button.interactBox.height * SCALE);
    }

    if(!button.enabled)
    {
        ctx.fillStyle = "black";
        ctx.globalAlpha = 0.3;
        ctx.fillRect(
            button.interactBox.x * SCALE,
            button.interactBox.y * SCALE,
            button.interactBox.width * SCALE,
            button.interactBox.height * SCALE);
    }

    ctx.restore();
}

export function drawVillager(villager, x, y, scale)
{
    ctx.drawImage(img.villagerShirt,
        x * SCALE,
        (y - 16) * SCALE,
        16 * scale * SCALE, 32 * scale * SCALE);
    
    let shirtData = ctx.getImageData(
        x * SCALE,
        y * SCALE,
        16 * scale * SCALE, 32 * scale * SCALE);

    for(let i = 0; i < shirtData.data.length; i += 4)
    {
        if(shirtData.data[i] == 255 && shirtData.data[i+1] == 0 && shirtData.data[i+2] == 255)
        {
            shirtData.data[i] = villager.shirtColor.r;
            shirtData.data[i+1] = villager.shirtColor.g;
            shirtData.data[i+2] = villager.shirtColor.b;
        }
    }

    ctx.putImageData(shirtData, 
        x * SCALE,
        y * SCALE);

    ctx.drawImage(img.villagerHeadarms,
        x * SCALE,
        (y - 16) * SCALE,
        16 * scale * SCALE, 32 * scale * SCALE);

    ctx.drawImage(img.villagerHair,
        16 * villager.hairStyle, 0,
        16, 32,
        x * SCALE,
        (y - 16) * SCALE,
        16 * scale * SCALE, 32 * scale * SCALE);

    let hairData = ctx.getImageData(
        x * SCALE,
        (y - 16) * SCALE,
        16 * scale * SCALE, 30 * scale * SCALE);

    for(let i = 0; i < hairData.data.length; i += 4)
    {
        if(hairData.data[i] == 255 && hairData.data[i+1] == 0 && hairData.data[i+2] == 255)
        {
            hairData.data[i] = villager.hairColor.r;
            hairData.data[i+1] = villager.hairColor.g;
            hairData.data[i+2] = villager.hairColor.b;
        }

        // turn skin green if sick
        if(villager.sick && i > hairData.data.length / 2)
        {
            if(hairData.data[i] == 255 && hairData.data[i+1] == 215 && hairData.data[i+2] == 190)
            {
                hairData.data[i] = 180;
                hairData.data[i+1] = 240;
                hairData.data[i+2] = 170;
            }
        }
    }

    ctx.putImageData(hairData,
        x * SCALE,
        (y - 16) * SCALE);
}

export function drawGrayscale(image, x, y, width, height)
{
    ctx.drawImage(image, x, y, width, height);

    let data = ctx.getImageData(x, y, width, height);
    let pixels = data.data;
    for(let i = 0; i < pixels.length; i += 4)
    {
        let lightness = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
        lightness = Math.max(0, lightness - 10);

        pixels[i] = lightness;
        pixels[i+1] = lightness;
        pixels[i+2] = lightness;
    }
    ctx.putImageData(data, x, y);
}

export function gameOver(msg)
{
    setTimeout(() => alert(msg), 10);

    location.reload();
}

================
File: client/index.html
================
<!DOCTYPE html>
<html>
<head>
    <title>It Takes a Village</title>
    <link rel="icon" href="data:,">
    <link rel="stylesheet" href="styles.css">
    <script type="module" src="js/socket.io.js"></script>

    <script type="module" src="index.js"></script>
</head>
<body>
    <div id="wrapper">
        <canvas id="canvas" oncontextmenu="return false"></canvas>
    </div>
</body>
</html>

================
File: client/index.js
================
import * as global from "./global.js";
Object.entries(global).forEach(([name, exported]) => window[name] = exported);

import * as sm from "./src/SceneManager.js";

socket.on("connect", () => {
    console.log("connected: " + socket.id);
    socketId = socket.id;
});

socket.on("server_info", (_games) => {
    console.log(_games);
});

window.addEventListener("keydown", (e) => {
    // if(e.key == "v")
    //     socket.emit("server_info");
});

sm.loadScene(sm.SCENE.menu);

================
File: client/js/socket.io.js
================
/*!
 * Socket.IO v4.0.1
 * (c) 2014-2021 Guillermo Rauch
 * Released under the MIT License.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["io"] = factory();
	else
		root["io"] = factory();
})(self, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = exports.io = exports.Manager = exports.protocol = void 0;

var url_1 = __webpack_require__(/*! ./url */ "./build/url.js");

var manager_1 = __webpack_require__(/*! ./manager */ "./build/manager.js");

var socket_1 = __webpack_require__(/*! ./socket */ "./build/socket.js");

Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
});

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client");
/**
 * Module exports.
 */


module.exports = exports = lookup;
/**
 * Managers cache.
 */

var cache = exports.managers = {};

function lookup(uri, opts) {
  if (_typeof(uri) === "object") {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};
  var parsed = url_1.url(uri, opts.path);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id]["nsps"];
  var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  var io;

  if (newConnection) {
    debug("ignoring socket cache for %s", source);
    io = new manager_1.Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug("new io instance for %s", source);
      cache[id] = new manager_1.Manager(source, opts);
    }

    io = cache[id];
  }

  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }

  return io.socket(parsed.path, opts);
}

exports.io = lookup;
/**
 * Protocol version.
 *
 * @public
 */

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

Object.defineProperty(exports, "protocol", {
  enumerable: true,
  get: function get() {
    return socket_io_parser_1.protocol;
  }
});
/**
 * `connect`.
 *
 * @param {String} uri
 * @public
 */

exports.connect = lookup;
/**
 * Expose constructors for standalone build.
 *
 * @public
 */

var manager_2 = __webpack_require__(/*! ./manager */ "./build/manager.js");

Object.defineProperty(exports, "Manager", {
  enumerable: true,
  get: function get() {
    return manager_2.Manager;
  }
});
exports["default"] = lookup;

/***/ }),

/***/ "./build/manager.js":
/*!**************************!*\
  !*** ./build/manager.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = void 0;

var eio = __webpack_require__(/*! engine.io-client */ "./node_modules/engine.io-client/lib/index.js");

var socket_1 = __webpack_require__(/*! ./socket */ "./build/socket.js");

var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var on_1 = __webpack_require__(/*! ./on */ "./build/on.js");

var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./build/typed-events.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client:manager");

var Manager = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Manager, _typed_events_1$Stric);

  var _super = _createSuper(Manager);

  function Manager(uri, opts) {
    var _this;

    _classCallCheck(this, Manager);

    _this = _super.call(this);
    _this.nsps = {};
    _this.subs = [];

    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    _this.opts = opts;

    _this.reconnection(opts.reconnection !== false);

    _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);

    _this.reconnectionDelay(opts.reconnectionDelay || 1000);

    _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);

    _this.randomizationFactor(opts.randomizationFactor || 0.5);

    _this.backoff = new Backoff({
      min: _this.reconnectionDelay(),
      max: _this.reconnectionDelayMax(),
      jitter: _this.randomizationFactor()
    });

    _this.timeout(null == opts.timeout ? 20000 : opts.timeout);

    _this._readyState = "closed";
    _this.uri = uri;

    var _parser = opts.parser || parser;

    _this.encoder = new _parser.Encoder();
    _this.decoder = new _parser.Decoder();
    _this._autoConnect = opts.autoConnect !== false;
    if (_this._autoConnect) _this.open();
    return _this;
  }

  _createClass(Manager, [{
    key: "reconnection",
    value: function reconnection(v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
  }, {
    key: "reconnectionAttempts",
    value: function reconnectionAttempts(v) {
      if (v === undefined) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
  }, {
    key: "reconnectionDelay",
    value: function reconnectionDelay(v) {
      var _a;

      if (v === undefined) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    }
  }, {
    key: "randomizationFactor",
    value: function randomizationFactor(v) {
      var _a;

      if (v === undefined) return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    }
  }, {
    key: "reconnectionDelayMax",
    value: function reconnectionDelayMax(v) {
      var _a;

      if (v === undefined) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    }
  }, {
    key: "timeout",
    value: function timeout(v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */

  }, {
    key: "maybeReconnectOnOpen",
    value: function maybeReconnectOnOpen() {
      // Only try to reconnect if it's the first time we're connecting
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */

  }, {
    key: "open",
    value: function open(fn) {
      var _this2 = this;

      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open")) return this;
      debug("opening %s", this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this._readyState = "opening";
      this.skipReconnect = false; // emit `open`

      var openSubDestroy = on_1.on(socket, "open", function () {
        self.onopen();
        fn && fn();
      }); // emit `error`

      var errorSub = on_1.on(socket, "error", function (err) {
        debug("error");
        self.cleanup();
        self._readyState = "closed";

        _this2.emitReserved("error", err);

        if (fn) {
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          self.maybeReconnectOnOpen();
        }
      });

      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);

        if (timeout === 0) {
          openSubDestroy(); // prevents a race condition with the 'open' event
        } // set timer


        var timer = setTimeout(function () {
          debug("connect attempt timed out after %d", timeout);
          openSubDestroy();
          socket.close();
          socket.emit("error", new Error("timeout"));
        }, timeout);

        if (this.opts.autoUnref) {
          timer.unref();
        }

        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }

      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */

  }, {
    key: "connect",
    value: function connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */

  }, {
    key: "onopen",
    value: function onopen() {
      debug("open"); // clear old subs

      this.cleanup(); // mark as open

      this._readyState = "open";
      this.emitReserved("open"); // add new subs

      var socket = this.engine;
      this.subs.push(on_1.on(socket, "ping", this.onping.bind(this)), on_1.on(socket, "data", this.ondata.bind(this)), on_1.on(socket, "error", this.onerror.bind(this)), on_1.on(socket, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */

  }, {
    key: "onping",
    value: function onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */

  }, {
    key: "ondata",
    value: function ondata(data) {
      this.decoder.add(data);
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */

  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      this.emitReserved("packet", packet);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      debug("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */

  }, {
    key: "socket",
    value: function socket(nsp, opts) {
      var socket = this.nsps[nsp];

      if (!socket) {
        socket = new socket_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
      }

      return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */

  }, {
    key: "_destroy",
    value: function _destroy(socket) {
      var nsps = Object.keys(this.nsps);

      for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
        var nsp = _nsps[_i];
        var _socket = this.nsps[nsp];

        if (_socket.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }

      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "_packet",
    value: function _packet(packet) {
      debug("writing packet %j", packet);
      var encodedPackets = this.encoder.encode(packet);

      for (var i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      debug("cleanup");
      this.subs.forEach(function (subDestroy) {
        return subDestroy();
      });
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */

  }, {
    key: "_close",
    value: function _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;

      if ("opening" === this._readyState) {
        // `onclose` will not fire because
        // an open event never happened
        this.cleanup();
      }

      this.backoff.reset();
      this._readyState = "closed";
      if (this.engine) this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("onclose");
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason);

      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */

  }, {
    key: "reconnect",
    value: function reconnect() {
      var _this3 = this;

      if (this._reconnecting || this.skipReconnect) return this;
      var self = this;

      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this._reconnecting = true;
        var timer = setTimeout(function () {
          if (self.skipReconnect) return;
          debug("attempting reconnect");

          _this3.emitReserved("reconnect_attempt", self.backoff.attempts); // check again for the case socket closed in above events


          if (self.skipReconnect) return;
          self.open(function (err) {
            if (err) {
              debug("reconnect attempt error");
              self._reconnecting = false;
              self.reconnect();

              _this3.emitReserved("reconnect_error", err);
            } else {
              debug("reconnect success");
              self.onreconnect();
            }
          });
        }, delay);

        if (this.opts.autoUnref) {
          timer.unref();
        }

        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */

  }, {
    key: "onreconnect",
    value: function onreconnect() {
      var attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }]);

  return Manager;
}(typed_events_1.StrictEventEmitter);

exports.Manager = Manager;

/***/ }),

/***/ "./build/on.js":
/*!*********************!*\
  !*** ./build/on.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.on = void 0;

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

exports.on = on;

/***/ }),

/***/ "./build/socket.js":
/*!*************************!*\
  !*** ./build/socket.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var on_1 = __webpack_require__(/*! ./on */ "./build/on.js");

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./build/typed-events.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client:socket");
/**
 * Internal events.
 * These events can't be emitted by the user.
 */


var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});

var Socket = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Socket, _typed_events_1$Stric);

  var _super = _createSuper(Socket);

  /**
   * `Socket` constructor.
   *
   * @public
   */
  function Socket(io, nsp, opts) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _super.call(this);
    _this.receiveBuffer = [];
    _this.sendBuffer = [];
    _this.ids = 0;
    _this.acks = {};
    _this.flags = {};
    _this.io = io;
    _this.nsp = nsp;
    _this.ids = 0;
    _this.acks = {};
    _this.receiveBuffer = [];
    _this.sendBuffer = [];
    _this.connected = false;
    _this.disconnected = true;
    _this.flags = {};

    if (opts && opts.auth) {
      _this.auth = opts.auth;
    }

    if (_this.io._autoConnect) _this.open();
    return _this;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */


  _createClass(Socket, [{
    key: "subEvents",
    value: function subEvents() {
      if (this.subs) return;
      var io = this.io;
      this.subs = [on_1.on(io, "open", this.onopen.bind(this)), on_1.on(io, "packet", this.onpacket.bind(this)), on_1.on(io, "error", this.onerror.bind(this)), on_1.on(io, "close", this.onclose.bind(this))];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects
     */

  }, {
    key: "connect",

    /**
     * "Opens" the socket.
     *
     * @public
     */
    value: function connect() {
      if (this.connected) return this;
      this.subEvents();
      if (!this.io["_reconnecting"]) this.io.open(); // ensure open

      if ("open" === this.io._readyState) this.onopen();
      return this;
    }
    /**
     * Alias for connect()
     */

  }, {
    key: "open",
    value: function open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @return self
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev + '" is a reserved event name');
      }

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      args.unshift(ev);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false; // event ack callback

      if ("function" === typeof args[args.length - 1]) {
        debug("emitting packet with ack id %d", this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }

      var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      var discardPacket = this.flags["volatile"] && (!isTransportWritable || !this.connected);

      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }

      this.flags = {};
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "packet",
    value: function packet(_packet) {
      _packet.nsp = this.nsp;

      this.io._packet(_packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */

  }, {
    key: "onopen",
    value: function onopen() {
      var _this2 = this;

      debug("transport is open - connecting");

      if (typeof this.auth == "function") {
        this.auth(function (data) {
          _this2.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: data
          });
        });
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT,
          data: this.auth
        });
      }
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("close (%s)", reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emitReserved("disconnect", reason);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onpacket",
    value: function onpacket(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace) return;

      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            var id = packet.data.sid;
            this.onconnect(id);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }

          break;

        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;

        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          var err = new Error(packet.data.message); // @ts-ignore

          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onevent",
    value: function onevent(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);

      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }

      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();

        var _iterator = _createForOfIteratorHelper(listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      _get(_getPrototypeOf(Socket.prototype), "emit", this).apply(this, args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */

  }, {
    key: "ack",
    value: function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        debug("sending ack %j", args);
        self.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id: id,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */

  }, {
    key: "onack",
    value: function onack(packet) {
      var ack = this.acks[packet.id];

      if ("function" === typeof ack) {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */

  }, {
    key: "onconnect",
    value: function onconnect(id) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.connected = true;
      this.disconnected = false;
      this.emitReserved("connect");
      this.emitBuffered();
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */

  }, {
    key: "emitBuffered",
    value: function emitBuffered() {
      var _this3 = this;

      this.receiveBuffer.forEach(function (args) {
        return _this3.emitEvent(args);
      });
      this.receiveBuffer = [];
      this.sendBuffer.forEach(function (packet) {
        return _this3.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */

  }, {
    key: "ondisconnect",
    value: function ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        this.subs.forEach(function (subDestroy) {
          return subDestroy();
        });
        this.subs = undefined;
      }

      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually.
     *
     * @return self
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({
          type: socket_io_parser_1.PacketType.DISCONNECT
        });
      } // remove socket from pool


      this.destroy();

      if (this.connected) {
        // fire events
        this.onclose("io client disconnect");
      }

      return this;
    }
    /**
     * Alias for disconnect()
     *
     * @return self
     * @public
     */

  }, {
    key: "close",
    value: function close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @returns self
     * @public
     */

  }, {
    key: "onAny",

    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */
    value: function onAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.push(listener);

      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */

  }, {
    key: "prependAny",
    value: function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.unshift(listener);

      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */

  }, {
    key: "offAny",
    value: function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }

      if (listener) {
        var listeners = this._anyListeners;

        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }

      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */

  }, {
    key: "listenersAny",
    value: function listenersAny() {
      return this._anyListeners || [];
    }
  }, {
    key: "active",
    get: function get() {
      return !!this.subs;
    }
  }, {
    key: "volatile",
    get: function get() {
      this.flags["volatile"] = true;
      return this;
    }
  }]);

  return Socket;
}(typed_events_1.StrictEventEmitter);

exports.Socket = Socket;

/***/ }),

/***/ "./build/typed-events.js":
/*!*******************************!*\
  !*** ./build/typed-events.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StrictEventEmitter = void 0;

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */


var StrictEventEmitter = /*#__PURE__*/function (_Emitter) {
  _inherits(StrictEventEmitter, _Emitter);

  var _super = _createSuper(StrictEventEmitter);

  function StrictEventEmitter() {
    _classCallCheck(this, StrictEventEmitter);

    return _super.apply(this, arguments);
  }

  _createClass(StrictEventEmitter, [{
    key: "on",

    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    value: function on(ev, listener) {
      _get(_getPrototypeOf(StrictEventEmitter.prototype), "on", this).call(this, ev, listener);

      return this;
    }
    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */

  }, {
    key: "once",
    value: function once(ev, listener) {
      _get(_getPrototypeOf(StrictEventEmitter.prototype), "once", this).call(this, ev, listener);

      return this;
    }
    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_get2 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get2, [this, ev].concat(args));

      return this;
    }
    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */

  }, {
    key: "emitReserved",
    value: function emitReserved(ev) {
      var _get3;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_get3 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get3, [this, ev].concat(args));

      return this;
    }
    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */

  }, {
    key: "listeners",
    value: function listeners(event) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "listeners", this).call(this, event);
    }
  }]);

  return StrictEventEmitter;
}(Emitter);

exports.StrictEventEmitter = StrictEventEmitter;

/***/ }),

/***/ "./build/url.js":
/*!**********************!*\
  !*** ./build/url.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.url = void 0;

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-client:url");
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */


function url(uri) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var loc = arguments.length > 2 ? arguments[2] : undefined;
  var obj = uri; // default to window.location

  loc = loc || typeof location !== "undefined" && location;
  if (null == uri) uri = loc.protocol + "//" + loc.host; // relative path support

  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug("protocol-less url %s", uri);

      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    } // parse


    debug("parse %s", uri);
    obj = parseuri(uri);
  } // make sure we treat `localhost:80` and `localhost` equally


  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }

  obj.path = obj.path || "/";
  var ipv6 = obj.host.indexOf(":") !== -1;
  var host = ipv6 ? "[" + obj.host + "]" : obj.host; // define unique id

  obj.id = obj.protocol + "://" + host + ":" + obj.port + path; // define href

  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

exports.url = url;

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Expose `Backoff`.
 */
module.exports = Backoff;
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */


Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);

  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }

  return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */


Backoff.prototype.reset = function () {
  this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */


Backoff.prototype.setMin = function (min) {
  this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */


Backoff.prototype.setMax = function (max) {
  this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */


Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  } // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.


  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        return enableOverride === null ? createDebug.enabled(namespace) : enableOverride;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/globalThis.browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/globalThis.browser.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
}();

/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Socket = __webpack_require__(/*! ./socket */ "./node_modules/engine.io-client/lib/socket.js");

module.exports = function (uri, opts) {
  return new Socket(uri, opts);
};
/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */


module.exports.Socket = Socket;
module.exports.protocol = Socket.protocol; // this is an int

module.exports.Transport = __webpack_require__(/*! ./transport */ "./node_modules/engine.io-client/lib/transport.js");
module.exports.transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
module.exports.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:socket");

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");

var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

var Socket = /*#__PURE__*/function (_Emitter) {
  _inherits(Socket, _Emitter);

  var _super = _createSuper(Socket);

  /**
   * Socket constructor.
   *
   * @param {String|Object} uri or options
   * @param {Object} options
   * @api public
   */
  function Socket(uri) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Socket);

    _this = _super.call(this);

    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = null;
    }

    if (uri) {
      uri = parseuri(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query) opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parseuri(opts.host).host;
    }

    _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;

    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = _this.secure ? "443" : "80";
    }

    _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? 443 : 80);
    _this.transports = opts.transports || ["polling", "websocket"];
    _this.readyState = "";
    _this.writeBuffer = [];
    _this.prevBufferLen = 0;
    _this.opts = _extends({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      jsonp: true,
      timestampParam: "t",
      rememberUpgrade: false,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {}
    }, opts);
    _this.opts.path = _this.opts.path.replace(/\/$/, "") + "/";

    if (typeof _this.opts.query === "string") {
      _this.opts.query = parseqs.decode(_this.opts.query);
    } // set on handshake


    _this.id = null;
    _this.upgrades = null;
    _this.pingInterval = null;
    _this.pingTimeout = null; // set on heartbeat

    _this.pingTimeoutTimer = null;

    if (typeof addEventListener === "function") {
      addEventListener("beforeunload", function () {
        if (_this.transport) {
          // silently close the transport
          _this.transport.removeAllListeners();

          _this.transport.close();
        }
      }, false);

      if (_this.hostname !== "localhost") {
        _this.offlineEventListener = function () {
          _this.onClose("transport close");
        };

        addEventListener("offline", _this.offlineEventListener, false);
      }
    }

    _this.open();

    return _this;
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} transport name
   * @return {Transport}
   * @api private
   */


  _createClass(Socket, [{
    key: "createTransport",
    value: function createTransport(name) {
      debug('creating transport "%s"', name);
      var query = clone(this.opts.query); // append engine.io protocol identifier

      query.EIO = parser.protocol; // transport name

      query.transport = name; // session id if we already have one

      if (this.id) query.sid = this.id;

      var opts = _extends({}, this.opts.transportOptions[name], this.opts, {
        query: query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      });

      debug("options: %j", opts);
      return new transports[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @api private
     */

  }, {
    key: "open",
    value: function open() {
      var transport;

      if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport = "websocket";
      } else if (0 === this.transports.length) {
        // Emit error on next tick so it can be listened to
        var self = this;
        setTimeout(function () {
          self.emit("error", "No transports available");
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }

      this.readyState = "opening"; // Retry with the next transport if the transport is disabled (jsonp: false)

      try {
        transport = this.createTransport(transport);
      } catch (e) {
        debug("error while creating transport: %s", e);
        this.transports.shift();
        this.open();
        return;
      }

      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @api private
     */

  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      debug("setting transport %s", transport.name);
      var self = this;

      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      } // set up transport


      this.transport = transport; // set up transport listeners

      transport.on("drain", function () {
        self.onDrain();
      }).on("packet", function (packet) {
        self.onPacket(packet);
      }).on("error", function (e) {
        self.onError(e);
      }).on("close", function () {
        self.onClose("transport close");
      });
    }
    /**
     * Probes a transport.
     *
     * @param {String} transport name
     * @api private
     */

  }, {
    key: "probe",
    value: function probe(name) {
      debug('probing transport "%s"', name);
      var transport = this.createTransport(name, {
        probe: 1
      });
      var failed = false;
      var self = this;
      Socket.priorWebsocketSuccess = false;

      function onTransportOpen() {
        if (self.onlyBinaryUpgrades) {
          var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }

        if (failed) return;
        debug('probe transport "%s" opened', name);
        transport.send([{
          type: "ping",
          data: "probe"
        }]);
        transport.once("packet", function (msg) {
          if (failed) return;

          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            self.upgrading = true;
            self.emit("upgrading", transport);
            if (!transport) return;
            Socket.priorWebsocketSuccess = "websocket" === transport.name;
            debug('pausing current transport "%s"', self.transport.name);
            self.transport.pause(function () {
              if (failed) return;
              if ("closed" === self.readyState) return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              self.setTransport(transport);
              transport.send([{
                type: "upgrade"
              }]);
              self.emit("upgrade", transport);
              transport = null;
              self.upgrading = false;
              self.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            var err = new Error("probe error");
            err.transport = transport.name;
            self.emit("upgradeError", err);
          }
        });
      }

      function freezeTransport() {
        if (failed) return; // Any callback called by transport should be ignored since now

        failed = true;
        cleanup();
        transport.close();
        transport = null;
      } // Handle any error that happens while probing


      function onerror(err) {
        var error = new Error("probe error: " + err);
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        self.emit("upgradeError", error);
      }

      function onTransportClose() {
        onerror("transport closed");
      } // When the socket is closed while we're probing


      function onclose() {
        onerror("socket closed");
      } // When the socket is upgraded while we're probing


      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      } // Remove all listeners on the transport and on self


      function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        self.removeListener("close", onclose);
        self.removeListener("upgrading", onupgrade);
      }

      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      transport.open();
    }
    /**
     * Called when connection is deemed open.
     *
     * @api public
     */

  }, {
    key: "onOpen",
    value: function onOpen() {
      debug("socket open");
      this.readyState = "open";
      Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emit("open");
      this.flush(); // we check for `readyState` in case an `open`
      // listener already closed the socket

      if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
        debug("starting upgrade probes");
        var i = 0;
        var l = this.upgrades.length;

        for (; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    }
    /**
     * Handles a packet.
     *
     * @api private
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emit("packet", packet); // Socket is live - any packet counts

        this.emit("heartbeat");

        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;

          case "ping":
            this.resetPingTimeout();
            this.sendPacket("pong");
            this.emit("pong");
            break;

          case "error":
            var err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;

          case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} handshake obj
     * @api private
     */

  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this.emit("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen(); // In case open handler closes socket

      if ("closed" === this.readyState) return;
      this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @api private
     */

  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout() {
      var _this2 = this;

      clearTimeout(this.pingTimeoutTimer);
      this.pingTimeoutTimer = setTimeout(function () {
        _this2.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);

      if (this.opts.autoUnref) {
        this.pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @api private
     */

  }, {
    key: "onDrain",
    value: function onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`

      this.prevBufferLen = 0;

      if (0 === this.writeBuffer.length) {
        this.emit("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @api private
     */

  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        debug("flushing %d packets in socket", this.writeBuffer.length);
        this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`

        this.prevBufferLen = this.writeBuffer.length;
        this.emit("flush");
      }
    }
    /**
     * Sends a message.
     *
     * @param {String} message.
     * @param {Function} callback function.
     * @param {Object} options.
     * @return {Socket} for chaining.
     * @api public
     */

  }, {
    key: "write",
    value: function write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
  }, {
    key: "send",
    value: function send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} callback function.
     * @api private
     */

  }, {
    key: "sendPacket",
    value: function sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = undefined;
      }

      if ("function" === typeof options) {
        fn = options;
        options = null;
      }

      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }

      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emit("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn) this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     *
     * @api private
     */

  }, {
    key: "close",
    value: function close() {
      var self = this;

      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";

        if (this.writeBuffer.length) {
          this.once("drain", function () {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }

      function close() {
        self.onClose("forced close");
        debug("socket closing - telling transport to close");
        self.transport.close();
      }

      function cleanupAndClose() {
        self.removeListener("upgrade", cleanupAndClose);
        self.removeListener("upgradeError", cleanupAndClose);
        close();
      }

      function waitForUpgrade() {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        self.once("upgrade", cleanupAndClose);
        self.once("upgradeError", cleanupAndClose);
      }

      return this;
    }
    /**
     * Called upon transport error
     *
     * @api private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      debug("socket error %j", err);
      Socket.priorWebsocketSuccess = false;
      this.emit("error", err);
      this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose(reason, desc) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason);
        var self = this; // clear timers

        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport

        this.transport.removeAllListeners("close"); // ensure transport won't stay open

        this.transport.close(); // ignore further transport communication

        this.transport.removeAllListeners();

        if (typeof removeEventListener === "function") {
          removeEventListener("offline", this.offlineEventListener, false);
        } // set ready state


        this.readyState = "closed"; // clear session id

        this.id = null; // emit close event

        this.emit("close", reason, desc); // clean buffers after, so users can still
        // grab the buffers on `close` event

        self.writeBuffer = [];
        self.prevBufferLen = 0;
      }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} server upgrades
     * @api private
     *
     */

  }, {
    key: "filterUpgrades",
    value: function filterUpgrades(upgrades) {
      var filteredUpgrades = [];
      var i = 0;
      var j = upgrades.length;

      for (; i < j; i++) {
        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }

      return filteredUpgrades;
    }
  }]);

  return Socket;
}(Emitter);

Socket.priorWebsocketSuccess = false;
/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

function clone(obj) {
  var o = {};

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }

  return o;
}

module.exports = Socket;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:transport");

var Transport = /*#__PURE__*/function (_Emitter) {
  _inherits(Transport, _Emitter);

  var _super = _createSuper(Transport);

  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */
  function Transport(opts) {
    var _this;

    _classCallCheck(this, Transport);

    _this = _super.call(this);
    _this.opts = opts;
    _this.query = opts.query;
    _this.readyState = "";
    _this.socket = opts.socket;
    return _this;
  }
  /**
   * Emits an error.
   *
   * @param {String} str
   * @return {Transport} for chaining
   * @api public
   */


  _createClass(Transport, [{
    key: "onError",
    value: function onError(msg, desc) {
      var err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
      return this;
    }
    /**
     * Opens the transport.
     *
     * @api public
     */

  }, {
    key: "open",
    value: function open() {
      if ("closed" === this.readyState || "" === this.readyState) {
        this.readyState = "opening";
        this.doOpen();
      }

      return this;
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "close",
    value: function close() {
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.doClose();
        this.onClose();
      }

      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      if ("open" === this.readyState) {
        this.write(packets);
      } else {
        // this might happen if the transport was silently closed in the beforeunload event handler
        debug("transport is not open, discarding packets");
      }
    }
    /**
     * Called upon open
     *
     * @api private
     */

  }, {
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open";
      this.writable = true;
      this.emit("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      this.emit("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  }]);

  return Transport;
}(Emitter);

module.exports = Transport;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var XMLHttpRequest = __webpack_require__(/*! ../../contrib/xmlhttprequest-ssl/XMLHttpRequest */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");

var XHR = __webpack_require__(/*! ./polling-xhr */ "./node_modules/engine.io-client/lib/transports/polling-xhr.js");

var JSONP = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js");

var websocket = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io-client/lib/transports/websocket.js");

exports.polling = polling;
exports.websocket = websocket;
/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== "undefined") {
    var isSSL = "https:" === location.protocol;
    var port = location.port; // some user agents have empty `location.port`

    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ("open" in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error("JSONP disabled");
    return new JSONP(opts);
  }
}

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");

var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;
/**
 * Global JSONP callbacks.
 */

var callbacks;

var JSONPPolling = /*#__PURE__*/function (_Polling) {
  _inherits(JSONPPolling, _Polling);

  var _super = _createSuper(JSONPPolling);

  /**
   * JSONP Polling constructor.
   *
   * @param {Object} opts.
   * @api public
   */
  function JSONPPolling(opts) {
    var _this;

    _classCallCheck(this, JSONPPolling);

    _this = _super.call(this, opts);
    _this.query = _this.query || {}; // define global callbacks array if not present
    // we do this here (lazily) to avoid unneeded global pollution

    if (!callbacks) {
      // we need to consider multiple engines in the same page
      callbacks = globalThis.___eio = globalThis.___eio || [];
    } // callback identifier


    _this.index = callbacks.length; // add callback to jsonp global

    var self = _assertThisInitialized(_this);

    callbacks.push(function (msg) {
      self.onData(msg);
    }); // append to query string

    _this.query.j = _this.index;
    return _this;
  }
  /**
   * JSONP only supports binary as base64 encoded strings
   */


  _createClass(JSONPPolling, [{
    key: "doClose",

    /**
     * Closes the socket.
     *
     * @api private
     */
    value: function doClose() {
      if (this.script) {
        // prevent spurious errors from being emitted when the window is unloaded
        this.script.onerror = function () {};

        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }

      _get(_getPrototypeOf(JSONPPolling.prototype), "doClose", this).call(this);
    }
    /**
     * Starts a poll cycle.
     *
     * @api private
     */

  }, {
    key: "doPoll",
    value: function doPoll() {
      var self = this;
      var script = document.createElement("script");

      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      script.async = true;
      script.src = this.uri();

      script.onerror = function (e) {
        self.onError("jsonp poll error", e);
      };

      var insertAt = document.getElementsByTagName("script")[0];

      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }

      this.script = script;
      var isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);

      if (isUAgecko) {
        setTimeout(function () {
          var iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    }
    /**
     * Writes with a hidden iframe.
     *
     * @param {String} data to send
     * @param {Function} called upon flush.
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, fn) {
      var self = this;
      var iframe;

      if (!this.form) {
        var form = document.createElement("form");
        var area = document.createElement("textarea");
        var id = this.iframeId = "eio_iframe_" + this.index;
        form.className = "socketio";
        form.style.position = "absolute";
        form.style.top = "-1000px";
        form.style.left = "-1000px";
        form.target = id;
        form.method = "POST";
        form.setAttribute("accept-charset", "utf-8");
        area.name = "d";
        form.appendChild(area);
        document.body.appendChild(form);
        this.form = form;
        this.area = area;
      }

      this.form.action = this.uri();

      function complete() {
        initIframe();
        fn();
      }

      function initIframe() {
        if (self.iframe) {
          try {
            self.form.removeChild(self.iframe);
          } catch (e) {
            self.onError("jsonp polling iframe removal error", e);
          }
        }

        try {
          // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
          var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement("iframe");
          iframe.name = self.iframeId;
          iframe.src = "javascript:0";
        }

        iframe.id = self.iframeId;
        self.form.appendChild(iframe);
        self.iframe = iframe;
      }

      initIframe(); // escape \n to prevent it from being converted into \r\n by some UAs
      // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side

      data = data.replace(rEscapedNewline, "\\\n");
      this.area.value = data.replace(rNewline, "\\n");

      try {
        this.form.submit();
      } catch (e) {}

      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function () {
          if (self.iframe.readyState === "complete") {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    }
  }, {
    key: "supportsBinary",
    get: function get() {
      return false;
    }
  }]);

  return JSONPPolling;
}(Polling);

module.exports = JSONPPolling;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* global attachEvent */
var XMLHttpRequest = __webpack_require__(/*! ../../contrib/xmlhttprequest-ssl/XMLHttpRequest */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var _require = __webpack_require__(/*! ../util */ "./node_modules/engine.io-client/lib/util.js"),
    pick = _require.pick;

var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:polling-xhr");
/**
 * Empty function
 */


function empty() {}

var hasXHR2 = function () {
  var xhr = new XMLHttpRequest({
    xdomain: false
  });
  return null != xhr.responseType;
}();

var XHR = /*#__PURE__*/function (_Polling) {
  _inherits(XHR, _Polling);

  var _super = _createSuper(XHR);

  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @api public
   */
  function XHR(opts) {
    var _this;

    _classCallCheck(this, XHR);

    _this = _super.call(this, opts);

    if (typeof location !== "undefined") {
      var isSSL = "https:" === location.protocol;
      var port = location.port; // some user agents have empty `location.port`

      if (!port) {
        port = isSSL ? 443 : 80;
      }

      _this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      _this.xs = opts.secure !== isSSL;
    }
    /**
     * XHR supports binary
     */


    var forceBase64 = opts && opts.forceBase64;
    _this.supportsBinary = hasXHR2 && !forceBase64;
    return _this;
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @api private
   */


  _createClass(XHR, [{
    key: "request",
    value: function request() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _extends(opts, {
        xd: this.xd,
        xs: this.xs
      }, this.opts);

      return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, fn) {
      var req = this.request({
        method: "POST",
        data: data
      });
      var self = this;
      req.on("success", fn);
      req.on("error", function (err) {
        self.onError("xhr post error", err);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @api private
     */

  }, {
    key: "doPoll",
    value: function doPoll() {
      debug("xhr poll");
      var req = this.request();
      var self = this;
      req.on("data", function (data) {
        self.onData(data);
      });
      req.on("error", function (err) {
        self.onError("xhr poll error", err);
      });
      this.pollXhr = req;
    }
  }]);

  return XHR;
}(Polling);

var Request = /*#__PURE__*/function (_Emitter) {
  _inherits(Request, _Emitter);

  var _super2 = _createSuper(Request);

  /**
   * Request constructor
   *
   * @param {Object} options
   * @api public
   */
  function Request(uri, opts) {
    var _this2;

    _classCallCheck(this, Request);

    _this2 = _super2.call(this);
    _this2.opts = opts;
    _this2.method = opts.method || "GET";
    _this2.uri = uri;
    _this2.async = false !== opts.async;
    _this2.data = undefined !== opts.data ? opts.data : null;

    _this2.create();

    return _this2;
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @api private
   */


  _createClass(Request, [{
    key: "create",
    value: function create() {
      var opts = pick(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this.opts.xd;
      opts.xscheme = !!this.opts.xs;
      var xhr = this.xhr = new XMLHttpRequest(opts);
      var self = this;

      try {
        debug("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);

        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);

            for (var i in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}

        if ("POST" === this.method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {}
        }

        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {} // ie6 check


        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }

        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }

        if (this.hasXDR()) {
          xhr.onload = function () {
            self.onLoad();
          };

          xhr.onerror = function () {
            self.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function () {
            if (4 !== xhr.readyState) return;

            if (200 === xhr.status || 1223 === xhr.status) {
              self.onLoad();
            } else {
              // make sure the `error` event handler that's user-set
              // does not throw in the same tick and gets caught here
              setTimeout(function () {
                self.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
        }

        debug("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        // Need to defer since .create() is called directly from the constructor
        // and thus the 'error' event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        setTimeout(function () {
          self.onError(e);
        }, 0);
        return;
      }

      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    }
    /**
     * Called upon successful response.
     *
     * @api private
     */

  }, {
    key: "onSuccess",
    value: function onSuccess() {
      this.emit("success");
      this.cleanup();
    }
    /**
     * Called if we have data.
     *
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      this.emit("data", data);
      this.onSuccess();
    }
    /**
     * Called upon error.
     *
     * @api private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      this.emit("error", err);
      this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @api private
     */

  }, {
    key: "cleanup",
    value: function cleanup(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      } // xmlhttprequest


      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty;
      } else {
        this.xhr.onreadystatechange = empty;
      }

      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {}
      }

      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }

      this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @api private
     */

  }, {
    key: "onLoad",
    value: function onLoad() {
      var data = this.xhr.responseText;

      if (data !== null) {
        this.onData(data);
      }
    }
    /**
     * Check if it has XDomainRequest.
     *
     * @api private
     */

  }, {
    key: "hasXDR",
    value: function hasXDR() {
      return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
    }
    /**
     * Aborts the request.
     *
     * @api public
     */

  }, {
    key: "abort",
    value: function abort() {
      this.cleanup();
    }
  }]);

  return Request;
}(Emitter);
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */


Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    var terminationEvent = "onpagehide" in globalThis ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

module.exports = XHR;
module.exports.Request = Request;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");

var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:polling");

var Polling = /*#__PURE__*/function (_Transport) {
  _inherits(Polling, _Transport);

  var _super = _createSuper(Polling);

  function Polling() {
    _classCallCheck(this, Polling);

    return _super.apply(this, arguments);
  }

  _createClass(Polling, [{
    key: "doOpen",

    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */
    value: function doOpen() {
      this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */

  }, {
    key: "pause",
    value: function pause(onPause) {
      var self = this;
      this.readyState = "pausing";

      function pause() {
        debug("paused");
        self.readyState = "paused";
        onPause();
      }

      if (this.polling || !this.writable) {
        var total = 0;

        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function () {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }

        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function () {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @api public
     */

  }, {
    key: "poll",
    value: function poll() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emit("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var self = this;
      debug("polling got data %s", data);

      var callback = function callback(packet, index, total) {
        // if its the first message we consider the transport open
        if ("opening" === self.readyState && packet.type === "open") {
          self.onOpen();
        } // if its a close packet, we close the ongoing requests


        if ("close" === packet.type) {
          self.onClose();
          return false;
        } // otherwise bypass onData and handle the message


        self.onPacket(packet);
      }; // decode payload


      parser.decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing

      if ("closed" !== this.readyState) {
        // if we got data we're not polling
        this.polling = false;
        this.emit("pollComplete");

        if ("open" === this.readyState) {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose() {
      var self = this;

      function close() {
        debug("writing close packet");
        self.write([{
          type: "close"
        }]);
      }

      if ("open" === this.readyState) {
        debug("transport open - closing");
        close();
      } else {
        // in case we're trying to close while
        // handshaking is in progress (GH-164)
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */

  }, {
    key: "write",
    value: function write(packets) {
      var _this = this;

      this.writable = false;
      parser.encodePayload(packets, function (data) {
        _this.doWrite(data, function () {
          _this.writable = true;

          _this.emit("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */

  }, {
    key: "uri",
    value: function uri() {
      var query = this.query || {};
      var schema = this.opts.secure ? "https" : "http";
      var port = ""; // cache busting is forced

      if (false !== this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      }

      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }

      query = parseqs.encode(query); // avoid port if default for schema

      if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      } // prepend ? to query


      if (query.length) {
        query = "?" + query;
      }

      var ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
  }, {
    key: "name",

    /**
     * Transport name.
     */
    get: function get() {
      return "polling";
    }
  }]);

  return Polling;
}(Transport);

module.exports = Polling;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var globalThis = __webpack_require__(/*! ../globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

module.exports = {
  WebSocket: globalThis.WebSocket || globalThis.MozWebSocket,
  usingBrowserWebSocket: true,
  defaultBinaryType: "arraybuffer"
};

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/index.js");

var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");

var _require = __webpack_require__(/*! ../util */ "./node_modules/engine.io-client/lib/util.js"),
    pick = _require.pick;

var _require2 = __webpack_require__(/*! ./websocket-constructor */ "./node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js"),
    WebSocket = _require2.WebSocket,
    usingBrowserWebSocket = _require2.usingBrowserWebSocket,
    defaultBinaryType = _require2.defaultBinaryType;

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("engine.io-client:websocket"); // detect ReactNative environment


var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";

var WS = /*#__PURE__*/function (_Transport) {
  _inherits(WS, _Transport);

  var _super = _createSuper(WS);

  /**
   * WebSocket transport constructor.
   *
   * @api {Object} connection options
   * @api public
   */
  function WS(opts) {
    var _this;

    _classCallCheck(this, WS);

    _this = _super.call(this, opts);
    _this.supportsBinary = !opts.forceBase64;
    return _this;
  }
  /**
   * Transport name.
   *
   * @api public
   */


  _createClass(WS, [{
    key: "doOpen",

    /**
     * Opens socket.
     *
     * @api private
     */
    value: function doOpen() {
      if (!this.check()) {
        // let probe timeout
        return;
      }

      var uri = this.uri();
      var protocols = this.opts.protocols; // React Native only supports the 'headers' option, and will print a warning if anything else is passed

      var opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");

      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }

      try {
        this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
      } catch (err) {
        return this.emit("error", err);
      }

      this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @api private
     */

  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var _this2 = this;

      this.ws.onopen = function () {
        if (_this2.opts.autoUnref) {
          _this2.ws._socket.unref();
        }

        _this2.onOpen();
      };

      this.ws.onclose = this.onClose.bind(this);

      this.ws.onmessage = function (ev) {
        return _this2.onData(ev.data);
      };

      this.ws.onerror = function (e) {
        return _this2.onError("websocket error", e);
      };
    }
    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */

  }, {
    key: "write",
    value: function write(packets) {
      var self = this;
      this.writable = false; // encodePacket efficient as it uses WS framing
      // no need for encodePayload

      var total = packets.length;
      var i = 0;
      var l = total;

      for (; i < l; i++) {
        (function (packet) {
          parser.encodePacket(packet, self.supportsBinary, function (data) {
            // always create a new object (GH-437)
            var opts = {};

            if (!usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }

              if (self.opts.perMessageDeflate) {
                var len = "string" === typeof data ? Buffer.byteLength(data) : data.length;

                if (len < self.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            } // Sometimes the websocket has already been closed but the browser didn't
            // have a chance of informing us about it yet, in that case send will
            // throw an error


            try {
              if (usingBrowserWebSocket) {
                // TypeError is thrown when passing the second argument on Safari
                self.ws.send(data);
              } else {
                self.ws.send(data, opts);
              }
            } catch (e) {
              debug("websocket closed before onclose event");
            }

            --total || done();
          });
        })(packets[i]);
      }

      function done() {
        self.emit("flush"); // fake drain
        // defer to next tick to allow Socket to clear writeBuffer

        setTimeout(function () {
          self.writable = true;
          self.emit("drain");
        }, 0);
      }
    }
    /**
     * Called upon close
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      Transport.prototype.onClose.call(this);
    }
    /**
     * Closes socket.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @api private
     */

  }, {
    key: "uri",
    value: function uri() {
      var query = this.query || {};
      var schema = this.opts.secure ? "wss" : "ws";
      var port = ""; // avoid port if default for schema

      if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      } // append timestamp to URI


      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      } // communicate binary support capabilities


      if (!this.supportsBinary) {
        query.b64 = 1;
      }

      query = parseqs.encode(query); // prepend ? to query

      if (query.length) {
        query = "?" + query;
      }

      var ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */

  }, {
    key: "check",
    value: function check() {
      return !!WebSocket && !("__initialize" in WebSocket && this.name === WS.prototype.name);
    }
  }, {
    key: "name",
    get: function get() {
      return "websocket";
    }
  }]);

  return WS;
}(Transport);

module.exports = WS;

/***/ }),

/***/ "./node_modules/engine.io-client/lib/util.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-client/lib/util.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports.pick = function (obj) {
  for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    attr[_key - 1] = arguments[_key];
  }

  return attr.reduce(function (acc, k) {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }

    return acc;
  }, {});
};

/***/ }),

/***/ "./node_modules/engine.io-client/lib/xmlhttprequest.js":
/*!*************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/xmlhttprequest.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// browser shim for xmlhttprequest module
var hasCORS = __webpack_require__(/*! has-cors */ "./node_modules/has-cors/index.js");

var globalThis = __webpack_require__(/*! ./globalThis */ "./node_modules/engine.io-client/lib/globalThis.browser.js");

module.exports = function (opts) {
  var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx

  var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217

  var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE

  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {} // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example


  try {
    if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {}

  if (!xdomain) {
    try {
      return new globalThis[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {}
  }
};

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/commons.js":
/*!******************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/commons.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var PACKET_TYPES = Object.create(null); // no Map = no polyfill

PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach(function (key) {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
module.exports = {
  PACKET_TYPES: PACKET_TYPES,
  PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE,
  ERROR_PACKET: ERROR_PACKET
};

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/decodePacket.browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/decodePacket.browser.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(/*! ./commons */ "./node_modules/engine.io-parser/lib/commons.js"),
    PACKET_TYPES_REVERSE = _require.PACKET_TYPES_REVERSE,
    ERROR_PACKET = _require.ERROR_PACKET;

var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var base64decoder;

if (withNativeArrayBuffer) {
  base64decoder = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
}

var decodePacket = function decodePacket(encodedPacket, binaryType) {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }

  var type = encodedPacket.charAt(0);

  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }

  var packetType = PACKET_TYPES_REVERSE[type];

  if (!packetType) {
    return ERROR_PACKET;
  }

  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};

var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
  if (base64decoder) {
    var decoded = base64decoder.decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return {
      base64: true,
      data: data
    }; // fallback for old browsers
  }
};

var mapBinary = function mapBinary(data, binaryType) {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;

    case "arraybuffer":
    default:
      return data;
    // assuming the data is already an ArrayBuffer
  }
};

module.exports = decodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/encodePacket.browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/encodePacket.browser.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(/*! ./commons */ "./node_modules/engine.io-parser/lib/commons.js"),
    PACKET_TYPES = _require.PACKET_TYPES;

var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function"; // ArrayBuffer.isView method is not defined in IE10

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};

var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
  var type = _ref.type,
      data = _ref.data;

  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data instanceof ArrayBuffer ? data : data.buffer);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  } // plain string


  return callback(PACKET_TYPES[type] + (data || ""));
};

var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
  var fileReader = new FileReader();

  fileReader.onload = function () {
    var content = fileReader.result.split(",")[1];
    callback("b" + content);
  };

  return fileReader.readAsDataURL(data);
};

module.exports = encodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var encodePacket = __webpack_require__(/*! ./encodePacket */ "./node_modules/engine.io-parser/lib/encodePacket.browser.js");

var decodePacket = __webpack_require__(/*! ./decodePacket */ "./node_modules/engine.io-parser/lib/decodePacket.browser.js");

var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    encodePacket(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;

      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};

var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];

  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);

    if (decodedPacket.type === "error") {
      break;
    }
  }

  return packets;
};

module.exports = {
  protocol: 4,
  encodePacket: encodePacket,
  encodePayload: encodePayload,
  decodePacket: decodePacket,
  decodePayload: decodePayload
};

/***/ }),

/***/ "./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function (chars) {
  "use strict";

  exports.encode = function (arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
        i,
        len = bytes.length,
        base64 = "";

    for (i = 0; i < len; i += 3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64 += chars[bytes[i + 2] & 63];
    }

    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode = function (base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length,
        i,
        p = 0,
        encoded1,
        encoded2,
        encoded3,
        encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;

      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i += 4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i + 1]);
      encoded3 = chars.indexOf(base64[i + 2]);
      encoded4 = chars.indexOf(base64[i + 3]);
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-cors/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */
try {
  module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\
  !*** ./node_modules/parseqs/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */


exports.decode = function (qs) {
  var qry = {};
  var pairs = qs.split('&');

  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }

  return qry;
};

/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseuri/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

module.exports = function parseuri(str) {
  var src = str,
      b = str.indexOf('['),
      e = str.indexOf(']');

  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }

  var m = re.exec(str || ''),
      uri = {},
      i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }

  uri.pathNames = pathNames(uri, uri['path']);
  uri.queryKey = queryKey(uri, uri['query']);
  return uri;
};

function pathNames(obj, path) {
  var regx = /\/{2,9}/g,
      names = path.replace(regx, "/").split("/");

  if (path.substr(0, 1) == '/' || path.length === 0) {
    names.splice(0, 1);
  }

  if (path.substr(path.length - 1, 1) == '/') {
    names.splice(names.length - 1, 1);
  }

  return names;
}

function queryKey(uri, query) {
  var data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/binary.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/binary.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reconstructPacket = exports.deconstructPacket = void 0;

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */


function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
}

exports.deconstructPacket = deconstructPacket;

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (is_binary_1.isBinary(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};

    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }

    return _newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */


function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
}

exports.reconstructPacket = reconstructPacket;

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }

  return data;
}

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var binary_1 = __webpack_require__(/*! ./binary */ "./node_modules/socket.io-parser/dist/binary.js");

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")("socket.io-parser");
/**
 * Protocol version.
 *
 * @public
 */


exports.protocol = 5;
var PacketType;

(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */


var Encoder = /*#__PURE__*/function () {
  function Encoder() {
    _classCallCheck(this, Encoder);
  }

  _createClass(Encoder, [{
    key: "encode",

    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    value: function encode(obj) {
      debug("encoding packet %j", obj);

      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_1.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }

      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */

  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type; // attachments if we have them

      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      } // if we have a namespace other than `/`
      // we append it followed by a comma `,`


      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      } // immediately followed by the id


      if (null != obj.id) {
        str += obj.id;
      } // json data


      if (null != obj.data) {
        str += JSON.stringify(obj.data);
      }

      debug("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */

  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = binary_1.deconstructPacket(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      return buffers; // write all the buffers
    }
  }]);

  return Encoder;
}();

exports.Encoder = Encoder;
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */

var Decoder = /*#__PURE__*/function (_Emitter) {
  _inherits(Decoder, _Emitter);

  var _super = _createSuper(Decoder);

  function Decoder() {
    _classCallCheck(this, Decoder);

    return _super.call(this);
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */


  _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;

      if (typeof obj === "string") {
        packet = this.decodeString(obj);

        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

          if (packet.attachments === 0) {
            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        } else {
          // non-binary full packet
          _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
        }
      } else if (is_binary_1.isBinary(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);

          if (packet) {
            // received final buffer
            this.reconstructor = null;

            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */

  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0; // look up type

      var p = {
        type: Number(str.charAt(0))
      };

      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      } // look up attachments if type binary


      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;

        while (str.charAt(++i) !== "-" && i != str.length) {}

        var buf = str.substring(start, i);

        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }

        p.attachments = Number(buf);
      } // look up namespace (if any)


      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;

        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }

        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      } // look up id


      var next = str.charAt(i + 1);

      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;

        while (++i) {
          var _c = str.charAt(i);

          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }

          if (i === str.length) break;
        }

        p.id = Number(str.substring(_start2, i + 1));
      } // look up json data


      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));

        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }

      debug("decoded %s as %j", str, p);
      return p;
    }
  }, {
    key: "destroy",

    /**
     * Deallocates a parser's resources
     */
    value: function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return _typeof(payload) === "object";

        case PacketType.DISCONNECT:
          return payload === undefined;

        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || _typeof(payload) === "object";

        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;

        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);

  return Decoder;
}(Emitter);

exports.Decoder = Decoder;

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    return false;
  }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */


var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);

    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */


  _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);

      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }

      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */

  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);

  return BinaryReconstructor;
}();

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/is-binary.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/is-binary.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasBinary = exports.isBinary = void 0;
var withNativeArrayBuffer = typeof ArrayBuffer === "function";

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */

function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}

exports.isBinary = isBinary;

function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }

  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (isBinary(obj)) {
    return true;
  }

  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

exports.hasBinary = hasBinary;

/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\
  !*** ./node_modules/yeast/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
    length = 64,
    map = {},
    seed = 0,
    i = 0,
    prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */

function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */


function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */


function yeast() {
  var now = encode(+new Date());
  if (now !== prev) return seed = 0, prev = now;
  return now + '.' + encode(seed++);
} //
// Map each character to its index.
//


for (; i < length; i++) {
  map[alphabet[i]] = i;
} //
// Expose the `yeast`, `encode` and `decode` functions.
//


yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;

/***/ })

/******/ });
});
//# sourceMappingURL=socket.io.js.map

================
File: client/scenes/HelpModal.js
================
export class HelpModal {
    constructor() {
        this.isVisible = false;
        this.content = `# It Takes a Village - Help Document

## Introduction
Welcome to "It Takes a Village"! This cooperative game challenges you and your fellow players to work together to build and manage a thriving village. Your goal is to upgrade all facilities to their maximum level while keeping your villagers happy and healthy.

## How to Play

### Roles
Each player takes on one of six roles, each with unique abilities:
- Chief: Can assign villagers to facilities
- Doctor: Can heal sick villagers and make them immune
- Scientist: Unlocks apple trees and predicts future events
- Sociologist: Can view villager happiness and remove least favorite tasks
- Farmer: Plants crops faster and can fertilize farmland
- Engineer: Can upgrade materials and convert bricks to steel

### Game Flow
1. The game progresses in turns, with each player taking actions on their turn.
2. Each turn represents one day in the village.
3. At the end of each day, various updates occur (villager status, crop growth, etc.).
4. Events occur periodically, affecting the village positively or negatively.

### Main Actions
- Assign villagers to facilities
- Plant and harvest crops
- Use materials to upgrade facilities
- Heal sick villagers
- Use your role's special ability

### Resources
- Budget: Used to purchase items from the shop
- Crops: Used to feed villagers
- Materials: Used to upgrade facilities

## How to Win
To win the game, you must upgrade all four main facilities (Water, Farming, Education, and Housing) to level 5. This requires careful resource management, strategic planning, and cooperation among all players.

## Key Strategies
1. Keep villagers fed and healthy to maintain high happiness levels.
2. Efficiently assign villagers to facilities based on their preferences and skills.
3. Manage your resources carefully, balancing between immediate needs and long-term goals.
4. Use each player's unique abilities to overcome challenges and optimize village growth.
5. Prepare for and mitigate the effects of negative events.

## Tips
- The Chief's ability to assign villagers is crucial for efficient resource generation.
- The Doctor's healing abilities can save you from losing villagers to sickness.
- The Scientist's event prediction can help you prepare for upcoming challenges.
- The Sociologist can help optimize villager happiness and productivity.
- The Farmer's abilities are vital for maintaining a steady food supply.
- The Engineer's material upgrades can significantly speed up facility improvements.

Remember, communication and cooperation between all players are key to success in "It Takes a Village"!`;
        this.scrollOffset = 0;
        this.lineHeight = 20;
        
        // Bind the event handlers to maintain correct 'this' context
        this.boundHandleClick = this.handleClick.bind(this);
        this.boundHandleScroll = this.handleScroll.bind(this);
    }

    show() {
        this.isVisible = true;
        this.scrollOffset = 0;
        // Add event listeners when showing the modal
        const canvas = document.querySelector('canvas');
        if (canvas) {
            canvas.addEventListener('click', this.boundHandleClick);
            canvas.addEventListener('wheel', this.boundHandleScroll);
        }
    }

    hide() {
        this.isVisible = false;
        // Remove event listeners when hiding the modal
        const canvas = document.querySelector('canvas');
        if (canvas) {
            canvas.removeEventListener('click', this.boundHandleClick);
            canvas.removeEventListener('wheel', this.boundHandleScroll);
        }
    }

    draw(ctx) {
        if (!this.isVisible) return;

        // Draw a semi-transparent background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        // Draw the modal
        const modalWidth = ctx.canvas.width * 0.8;
        const modalHeight = ctx.canvas.height * 0.8;
        const modalX = (ctx.canvas.width - modalWidth) / 2;
        const modalY = (ctx.canvas.height - modalHeight) / 2;

        ctx.fillStyle = 'white';
        ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

        // Create a clipping region for the content
        ctx.save();
        ctx.beginPath();
        ctx.rect(modalX + 20, modalY + 20, modalWidth - 40, modalHeight - 40);
        ctx.clip();

        // Draw the content
        ctx.font = '16px Arial';
        ctx.fillStyle = 'black';
        this.drawText(ctx, this.content, modalX + 20, modalY + 20 - this.scrollOffset, modalWidth - 40, modalHeight - 40);

        ctx.restore();

        // Draw close button
        ctx.fillStyle = 'red';
        ctx.fillRect(modalX + modalWidth - 40, modalY + 10, 30, 30);
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.fillText('X', modalX + modalWidth - 30, modalY + 30);

        // Draw scroll indicators
        if (this.scrollOffset > 0) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.moveTo(modalX + modalWidth / 2, modalY + 10);
            ctx.lineTo(modalX + modalWidth / 2 - 10, modalY + 30);
            ctx.lineTo(modalX + modalWidth / 2 + 10, modalY + 30);
            ctx.fill();
        }

        if (this.scrollOffset < this.maxScroll) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.moveTo(modalX + modalWidth / 2, modalY + modalHeight - 10);
            ctx.lineTo(modalX + modalWidth / 2 - 10, modalY + modalHeight - 30);
            ctx.lineTo(modalX + modalWidth / 2 + 10, modalY + modalHeight - 30);
            ctx.fill();
        }
    }

    drawText(ctx, text, x, y, maxWidth, maxHeight) {
        const lines = text.split('\n');
        let currentY = y;
        this.maxScroll = 0;

        lines.forEach(line => {
            if (line.startsWith('#')) {
                ctx.font = 'bold 20px Arial';
                this.lineHeight = 30;
            } else if (line.startsWith('##')) {
                ctx.font = 'bold 18px Arial';
                this.lineHeight = 25;
            } else {
                ctx.font = '16px Arial';
                this.lineHeight = 20;
            }

            const words = line.split(' ');
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + word + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;

                if (testWidth > maxWidth && currentLine !== '') {
                    ctx.fillText(currentLine, x, currentY);
                    currentLine = word + ' ';
                    currentY += this.lineHeight;
                    this.maxScroll = Math.max(this.maxScroll, currentY - y - maxHeight);
                } else {
                    currentLine = testLine;
                }
            });

            ctx.fillText(currentLine, x, currentY);
            currentY += this.lineHeight;
            this.maxScroll = Math.max(this.maxScroll, currentY - y - maxHeight);
        });
    }

    handleClick(e) {
        // Get the canvas and its bounding rectangle
        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();
        
        // Calculate the actual position within the canvas
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        // Convert client coordinates to canvas coordinates
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;

        // Calculate modal dimensions
        const modalWidth = canvas.width * 0.8;
        const modalHeight = canvas.height * 0.8;
        const modalX = (canvas.width - modalWidth) / 2;
        const modalY = (canvas.height - modalHeight) / 2;

        // Check if click is within close button bounds
        if (
            canvasX > modalX + modalWidth - 40 &&
            canvasX < modalX + modalWidth - 10 &&
            canvasY > modalY + 10 &&
            canvasY < modalY + 40
        ) {
            this.hide();
        }
    }

    handleScroll(e) {
        e.preventDefault();
        this.scrollOffset = Math.max(0, Math.min(this.maxScroll, this.scrollOffset + e.deltaY));
    }
}

================
File: client/scenes/SceneCredits.js
================
import * as global from "../global.js";
Object.entries(global).forEach(([name, exported]) => window[name] = exported);

import {img} from "../assets.js";

import * as sm from "../src/SceneManager.js";
import { Button } from "../src/Button.js";

const buttons = {
    menu: new Button(16*10, 16*18, 6*16, 2*16, "red", "menu"),
}

function onClick(e)
{
    if(buttonClick(buttons.menu))
    {
        sm.loadScene(sm.SCENE.menu);
    }
}

export function init()
{
    canvas.width = img.menu.width * SCALE;
    canvas.height = img.menu.height * SCALE;

    canvas.addEventListener("click", onClick);
}

export function exit()
{
    canvas.removeEventListener("click", onClick);
}

export function draw()
{
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "black";
    ctx.font = "48px Kenney Mini Square";
    ctx.textAlign = "center";
    ctx.fillText("credits", canvas.width / 2, 16*3*SCALE);

    ctx.font = "20px Arial";
    ctx.textAlign = "left";

    ctx.fillText("Game designed and developed by:", 16*3*SCALE, 16*6*SCALE);
    ctx.fillText("Kerrance Dai, Boming Zheng, and Paul Zou", 16*3*SCALE, 16*7*SCALE);

    ctx.fillText("Supervisor: Lori Scarlatos", 16*3*SCALE, 16*9*SCALE);

    ctx.fillText("Art by: Paul Zou and kenney.nl", 16*3*SCALE, 16*11*SCALE);

    ctx.fillText("Music: \"\" by ", 16*3*SCALE, 16*13*SCALE);
    ctx.fillText("Provided by DOVA-SYNDROME (id: 7692)", 16*3*SCALE, 16*14*SCALE);

    ctx.fillText("Sound effects by: ObsydianX (itch.io)", 16*3*SCALE, 16*16*SCALE);

    drawButton(buttons.menu);

    if(sm.currentScene == sm.SCENE.credits)
        requestAnimationFrame(draw);
}

================
File: client/scenes/SceneGame.js
================
import * as global from "../global.js";
Object.entries(global).forEach(([name, exported]) => window[name] = exported);

import {img, audio} from "../assets.js";

import * as sm from "../src/SceneManager.js";
import { Button } from "../src/Button.js";
import { ItemStack } from "../src/ItemStack.js";
import { Animation } from "../src/Animation.js";

import { Notification } from "../src/Notification.js";
import { NotificationSeason } from "../src/NotificationSeason.js";
import { NotificationEvent } from "../src/NotificationEvent.js";
import { NotificationArrival } from "../src/NotificationArrival.js";
import { NotificationFlee } from "../src/NotificationFlee.js";
import { NotificationQuest } from "../src/NotificationQuest.js";
import { DayNotification } from "../src/DayNotification.js";
import { ToolTip } from "../src/ToolTip.js";


// game variables ////////////////////////////////////////////////////////////////

const INVENTORY_SIZE = 32;                  // number of slots for inventory
const UPGRADE_MATERIAL_COST = 10;           // price for upgrading material
const HEAL_VILLAGER_COST = 40;              // price for healing a sick villager
const CROP_GROWTH_TIME = 3;                 // default number of days for crops to grow
const APPLE_HAPPINESS_BOOST = 10;           // number of happiness given by feeding an apple
const FERTILIZED_BONUS = 3;                 // number of extra crops given by fertilized farmland
const HARVEST_SEED_CHANCE = 0;              // probability for harvesting a crop to give its matching seed, formerly 0.1
const ACTION_POINTS = 8;                    // number of action points per day

let maxVillagers = 8;

let ACTION_COST = {
    UPGRADE_FACILITY: 4,
    PLANT_CROP: 1,
    HARVEST_CROP: 1,
    PICK_TREE: 1,
    CUT_TREE: 1,
    ASSIGN_VILLAGER: 1,
    HEAL_VILLAGER: 1,
    USE_MATERIAL: 1,
    SKILL: 6
};

let currentTurn = 0;
let actionPoints = 0;
let skillUsed = false;                  // whether or not skill has been used this turn

let day = 0;
let season = "";
let nextSeason = "";
let daysUntilNextSeason = 0;

let event = null;
let nextEvent = null;

let budget = 0;

let villagers = [];             // array of all villagers
let paths = [];
let movingVillager = null;      // villager being moved

let facilities = {};            // dictionary of each of the 4 facilities
let farm = [];                  // array of available farmland

let treesUnlocked = false;      // whether or not trees are unlocked
let trees = [];                 // array of apple trees

let shop = [];                  // array of shop items

let dailyLoot = [];             // array of available loot items
let lootAmount = 0;

let upgrades = 0;


// role specific

let healChances = 0;            // doctor
let reputation = 0;             // chief only
let displayHappiness = false;   // sociologist only



// event variarbles

let cropGrowthModifier = 0;     // + number of days for crops to grow
let priceMultiplier = 1;        // multiplier for shop items


// ui ////////////////////////////////////////////////////////////////

let musicOn = false;
let soundOn = true;

const ACTION_STATES = {
    NORMAL: 0,
    SELECT_FARMLAND: 1,
    SELECT_VILLAGER: 2
};

let actionState = ACTION_STATES.NORMAL;


const INVENTORY_BOX_SIZE = 2.5;
const INVENTORY_BOX_MARGIN = 0.1;

const INVENTORY_STATES = {
    NORMAL: 0,
    SELLING: 1,
    UPGRADING: 2
};

let inventoryState = INVENTORY_STATES.NORMAL;

let heldItemStack = null;           // currently held item stack
let assigningVillager = null;        // currently selected villager for assigning

let infoSelected = null;            // current selected Interactable object in info panel
let labelSelected = null;           // current highlighted Interactable object label

let windowStack = ["main"];         // stack of open windows

let notifications = [];             // list of notification cards
let currentNotif = null;            // currently displayed notification
let eventDescription = ""           // description of the current event

// let notificationBox = {x: 16*8, y: 16*8, width: 16*26, height: 16*6}
let notificationBox = {x: 16*34, y: 16*8, width: 0, height: 16*6}

let rainAnimation = new Animation([img.rain0, img.rain1], 15);
let cloudShadows = [];

let powerOnFrames = [];
for(let i = 1; i <= 26; i++)
    powerOnFrames.push(img["power_on_" + i]);

let powerOnAnimation = new Animation(powerOnFrames, 5);

// buttons ////////////////////////////////////////////////////////////////

const buttons = {
    skill: new Button(38.25*16, 16.5*16, 2.75*16, 2*16, "blue", "skill"),
    shop: new Button(35*16, 16.5*16, 2.75*16, 2*16, "green", "shop"),
    endTurn: new Button(35*16, 19*16, 6*16, 2*16, "pink", "end turn"),

    music: new Button(35*16, 14.5*16, 16*1.5, 16*1.5, "red", ""),
    sound: new Button(36.5*16, 14.5*16, 16*1.5, 16*1.5, "red", ""),
    inventory: new Button(38*16, 14.5*16, 16*1.5, 16*1.5, "red", img.inventory),
    help: new Button(39.5*16, 14.5*16, 16*1.5, 16*1.5, "red", ""),

    assignVillager: new Button(1*16, 17.75*16, 6*16, 1.5*16, "orange", "assign"),
    healVillager: new Button(1*16, 19.5*16, 6*16, 1.5*16, "blue", "heal"),
    
    harvestCrop: new Button(1*16, 16*16, 6*16, 1.5*16, "green", "harvest"),
    
    pickTree: new Button(1*16, 16*16, 6*16, 1.5*16, "green", "pick apple"),
    cutTree: new Button(1*16, 17.75*16, 6*16, 1.5*16, "red", "cut"),

    upgradeMaterial: new Button(22.5*16, 7.25*16, 4*16, 1.5*16, "red", " $" + UPGRADE_MATERIAL_COST),
    sellItem: new Button(27*16, 7.25*16, 4*16, 1.5*16, "green", "sell"),
    upgradeFacility: new Button(1*16, 19.5*16, 6*16, 1.5*16, "red", "upgrade")
};

const toolTips = {
    skill: new ToolTip(buttons.skill.interactBox.x + buttons.skill.interactBox.width, buttons.skill.interactBox.y, 4),
    shop: new ToolTip(buttons.shop.interactBox.x + buttons.shop.interactBox.width, buttons.shop.interactBox.y, 4),
    inventory: new ToolTip(buttons.inventory.interactBox.x + buttons.inventory.interactBox.width, buttons.inventory.interactBox.y, 4),
    event: new ToolTip(16*35 + 16*6, 16*7, 4),
}

// socket messages ////////////////////////////////////////////////////////////////

socket.on("change_turn", (_currentTurn) => {
    currentTurn = _currentTurn;
    actionPoints = ACTION_POINTS;
    skillUsed = false;
    refreshSkillButton();

    buttons.endTurn.enabled = isCurrentTurn();
    refreshAssignButton();
    refreshUpgradeFacilityButton();

    buttons.harvestCrop.enabled = isCurrentTurn();
    buttons.pickTree.enabled = isCurrentTurn();
    buttons.cutTree.enabled = isCurrentTurn();

    refreshInventoryButtons();

    if(role == "doctor")
    {
        if(difficulty === 'speed') {
            switch(facilities["housing"].level)
            {
                case 1: healChances = 3; break;
                case 2: healChances = 4; break;
                case 3: healChances = 5; break;
                default: break;
            }
        } else {
            switch(facilities["housing"].level)
            {
                case 1: healChances = 2; break;
                case 2: healChances = 3; break;
                case 3: healChances = 3; break;
                case 4: healChances = 4; break;
                case 5: healChances = 5; break;
                default: break;
            }
        }
    }
    else
        healChances = (rolesPresent["doctor"] || npcPresent["doctor"]) ? 1 : 0;


    if(selectedInfoType("villager"))
        infoSelected = villagers.find(obj => obj.name == infoSelected.name);

    refreshHealButton();
});

socket.on("purchase_npc", (_npcs) => {
    npcPresent = _npcs;

    if(npcPresent["doctor"])
    {
        healChances = 1;
        refreshHealButton();
    }
    if(npcPresent["scientist"])
    {
        treesUnlocked = true;
        refreshTrees();
    }

    // remove NPC from shop
    for (const [npc, present] of Object.entries(npcPresent)) {
        if(present)
        {
            let index = shop.findIndex(shopItem => shopItem.id == "npc_" + npc);
            if(index != -1)
                shop.splice(index, 1);
        }
    }

    // closeShop();
    refreshShop();

});

socket.on("daily_loot", (_loot, amount) => {

    buttons.endTurn.enabled = false;

    if(getActiveWindow() == "notification")
        windowStack.splice(windowStack.length - 1, 0, "daily_loot");
    else
        windowStack.push("daily_loot");

    dailyLoot = _loot;
    lootAmount = amount;
});

socket.on("day", (_day, _daysUntilNextSeason) => {
    day = _day;
    daysUntilNextSeason = _daysUntilNextSeason;

    DayNotification.reset(day);
});

socket.on("season", (_season, _nextSeason) => {

    let currentSeason = season;

    season = _season;
    nextSeason = _nextSeason;

    if(season == "game end")
        gameOver("game end");

    if(currentSeason != season)
    {
        notifications.push(new NotificationSeason(season));
        triggerNotifications();  
    }
});

socket.on("event", (_event, _nextEvent) => {

    if(!event || event.duration == 1)
    {
        notifications.push(new NotificationEvent(_event, img["event_" + _event.id]));
        eventDescription = _event.description
        triggerNotifications();

        cloudShadows = [];

        if(_event.id == "cloudy_day")
        {
            for(let i = 0; i < 8; i++)
            {
                let x = Math.random() * 16*22 + (8*16);
                let y = Math.random() * 16*22;
                let type = Math.floor(Math.random() * (img.cloudShadows.width / 64 + 1));
                cloudShadows.push({x, y, type});
            }
        }
        else if(_event.id == "flood")
        {
            for(let i = 0; i < 8; i++)
            {
                let x = Math.random() * 16*22 + (8*16);
                let y = Math.random() * 16*22;
                let type = Math.floor(Math.random() * (img.puddles.width / 16 + 1));
                cloudShadows.push({x, y, type});
            }
        }
        
    }

    event = _event;
    nextEvent = _nextEvent;
});

socket.on("mutate", () => {
    notifications.push(new Notification("some villager stats have mutated", 2500));
    triggerNotifications();
});

socket.on("budget", (_budget) => {
    budget = _budget;
});

socket.on("villager", (_villager) => {
    for(let i = 0; i < villagers.length; i++)
    {
        if(villagers[i].name == _villager.name)
        {
            villagers[i] = _villager;
            break;
        }
    }

    if(selectedInfoType("villager"))
    {
        infoSelected = villagers.find(obj => obj.name == infoSelected.name);
        refreshHealButton();
    }
});

socket.on("villagers", (_villagers) => {
    // check for new villager arrival
    if(villagers.length > 0 && _villagers.length > villagers.length)
    {
        let newVillager = null;
        for(let i = 0; i < _villagers.length; i++)
        {
            if(villagers.find(villager => villager.name == _villagers[i].name) == null)
            {
                newVillager = _villagers[i];
                notifications.push(new NotificationArrival(newVillager));
                triggerNotifications();
                break;
            }
        }
    }

    villagers = _villagers;

    if(selectedInfoType("villager"))
        infoSelected = villagers.find(obj => obj.name == infoSelected.name);
});

socket.on("max_villagers", (_maxVillagers) => {
    maxVillagers = _maxVillagers;
});

socket.on("paths", (_paths) => {
    paths = _paths;
});

socket.on("facility", (_facility) => {
    facilities[_facility.label] = _facility;

    upgrades = facilities["water"].level + facilities["farming"].level + facilities["education"].level + facilities["housing"].level - 4;

    // win condition
    const winThreshold = difficulty === 'speed' ? 8 : 12; // 8 for speed mode (level 3 on all) vs 12 for regular (level 4 on all)
    if(upgrades >= winThreshold)
    {
        sm.loadScene(sm.SCENE.win);
        return;
    }

    if(selectedInfoType("facility"))
    {
        infoSelected = facilities[infoSelected.label];
        refreshUpgradeFacilityButton();
    }
});

socket.on("facilities", (_facilities) => {
    facilities = _facilities;

    if(selectedInfoType("facility"))
    {
        infoSelected = facilities[infoSelected.label];
        refreshUpgradeFacilityButton();
    }
});

socket.on("shop", (_shop) => {
    shop = _shop;
    
    refreshShop();
});

socket.on("add_shop_item", (_shopItem) => {
    for(let i = 0; i < shop.length; i++)
    {
        if(shop[i].id == _shopItem.id)
            return;
    }

    shop.push(_shopItem);
    refreshShop();
});

socket.on("farm", (_farm) => {
    farm = _farm;

    if(selectedInfoType("farmland"))
        infoSelected = farm.find(obj => obj.id == infoSelected.id);
});

socket.on("trees", (_trees, _treesUnlocked) => {
    trees = _trees;
    treesUnlocked = _treesUnlocked;

    refreshTrees();

    if(selectedInfoType("tree"))
    {
        infoSelected = trees.find(obj => obj.id == infoSelected.id);
        refreshPickTreeButton();
        refreshCutTreeButton();
    }
});

socket.on("give_item", (_item, _amount) => {
    giveItem(_item, _amount);
});

socket.on("heal_chances", (_healChances) => {
    healChances = _healChances;
});

socket.on("villager_flee", (_villager) => {
    notifications.push(new NotificationFlee(_villager));
    triggerNotifications();
});

socket.on("quest_complete", (_villager, _playerName) => {
    notifications.push(new NotificationQuest(_villager, _playerName, _playerName == playerName));
    triggerNotifications();
});

socket.on("inventory", (_inventory) => {
    inventory = _inventory;
});

socket.on("set_variable", (_var, _value) => {
    switch(_var)
    {
        case "cropGrowthModifier":
            cropGrowthModifier = _value;
            break;
        case "priceMultiplier":
            priceMultiplier = _value;
            break;
        default:
            break;
    }
});

socket.on("reputation", (_reputation) => {
    reputation = _reputation;
});


// event handlers ////////////////////////////////////////////////////////////////

function onClick(e)
{
    // sm.loadScene(sm.SCENE.win);         // debug

    if(buttonClick(buttons.music))
    {
        musicOn = !musicOn;
        musicOn ? audio.bgm.play() : audio.bgm.pause();
        playClickSound();
        return;
    }

    if(buttonClick(buttons.sound))
    {
        soundOn = !soundOn;
        playClickSound();
        return;
    }

    if(getActiveWindow() == "notification") return;

    if(buttonClick(buttons.endTurn))
    {
        endTurn();
        playClickSound();
        return;
    }

    if(buttonClick(buttons.shop))
    {
        if(getActiveWindow() == "shop")
            closeShop();
        else
            openShop();

        playClickSound();
        return;
    }

    if(buttonClick(buttons.skill))
    {
        closeInventory();
        useSkill();
        playClickSound();
        return;
    }

    if(buttonClick(buttons.inventory))
    {
        if(getActiveWindow() == "inventory")
            closeInventory();
        else
            openInventory();

        playClickSound();
    }

    if(buttonClick(buttons.help))
    {
        if(getActiveWindow() == 'role')
            closeRole()
        else
            openRole();
        playClickSound();
    }

    if(selectedInfoType("farmland") && buttonClick(buttons.harvestCrop))
    {
        harvestCrop();
        playClickSound();
        return;
    }

    if(selectedInfoType("facility") && buttonClick(buttons.upgradeFacility))
    {
        useAction(ACTION_COST.UPGRADE_FACILITY);
        socket.emit("upgrade_facility", roomId, infoSelected);
        playClickSound();
        return;
    }

    if(selectedInfoType("villager"))
    {
        if(buttonClick(buttons.assignVillager))
        {
            startAssign();
            playClickSound();
            return;
        }
        else if(buttonClick(buttons.healVillager))
        {
            healVillager();
            playClickSound();
            return;
        }
        
    }

    if(selectedInfoType("tree"))
    {
        if(buttonClick(buttons.pickTree))
        {
            pickTree();
            playClickSound();
            return;
        }
        
        else if(buttonClick(buttons.cutTree))
        {
            cutTree();
            playClickSound();
            return;
        }
    }

    if(getActiveWindow() == "main")
    {
        let prevSelected = infoSelected;

        if(mouse.x > 8*16*SCALE && mouse.x < 34*16*SCALE)
            infoSelected = null;

        if(isHoldingFood())
        {
            let useItem = false;
            villagers.forEach(villager => {

                if(useItem || villager.fed || villager.hunger == 5) return;

                let obj = {
                    interactBox: {
                        x: (villager.position.x * 16 + 128),
                        y: (villager.position.y * 16 - 22),
                        width: 16,
                        height: 16
                    }
                };
    
                if(mouseInteract(obj))
                {
                    feedVillager(villager);
                    playClickSound();
                    useItem = true;
                }
            });

            if(useItem)
            {
                infoSelected = prevSelected;
                return;
            }
        }

        let useItem = false;

        if(!assigningVillager)
        {
            for(let i = 0; i < farm.length; i++)
            {
                let farmland = farm[i];
                if(!farmland.locked && mouseInteract(farmland))
                {
                    playClickSound();
                    if(actionState == ACTION_STATES.SELECT_FARMLAND)
                    {
                        farmland.fertilized = true;
                        actionState = ACTION_STATES.NORMAL;
                        useAction(ACTION_COST.SKILL);
                        skillUsed = true;
                        socket.emit("farm", roomId, farm);
                        return;
                    }
                    else if(!heldItemStack || farmland.crop)
                    {
                        infoSelected = farmland;
                        return;
                    }
                    else if(heldItemStack.item.type == "seed" && actionPoints >= ACTION_COST.PLANT_CROP)
                    {
                        infoSelected = prevSelected;
                        plantCrop(farmland);
                        useItem = true;
                        return;
                    }
                }
            }
        }

        if(!useItem)
        {
            Object.values(facilities).forEach(facility => {
                if(mouseInteract(facility))
                {
                    playClickSound();
                    if(assigningVillager)
                    {
                        finishAssign(facility);
                        infoSelected = prevSelected;
                    }
                    else if(heldItemStack && heldItemStack.item.type == "material" && actionPoints >= ACTION_COST.USE_MATERIAL)
                    {
                        useMaterial(facility);
                        infoSelected = facility;
                        refreshUpgradeFacilityButton();
                    }
                    else
                    {
                        infoSelected = facility;
                        refreshUpgradeFacilityButton();
                    }
                }
            });
        }
        
        if(infoSelected) return;

        villagers.forEach(villager => {
            if(mouseInteract(villager))
            {
                if(actionState == ACTION_STATES.SELECT_VILLAGER)
                {
                    if(role == "sociologist")
                    {
                        if(villager.leastFavoriteTask != "")
                        {
                            villager.leastEffectiveTask = "";
                            villager.leastFavoriteTask = "";
                            socket.emit("villager", roomId, villager);

                            actionState = ACTION_STATES.NORMAL;
                            useAction(ACTION_COST.SKILL);
                            skillUsed = true;
                        }
                    }

                    else if(role == "doctor")
                    {
                        if(!villager.immune)
                        {
                            villager.immune = true;
                            socket.emit("villager", roomId, villager);

                            actionState = ACTION_STATES.NORMAL;
                            useAction(ACTION_COST.SKILL);
                            skillUsed = true;
                        }
                    }
                    
                }

                if(assigningVillager)
                {
                    assigningVillager = null;
                    buttons.assignVillager.enabled = true;
                }
                playClickSound();
                infoSelected = villager;

                refreshHealButton();
            }
        });

        trees.forEach(tree => {
            if(mouseInteract(tree))
            {
                playClickSound();
                infoSelected = tree;

                if(actionState == ACTION_STATES.SELECT_FARMLAND && treesUnlocked && !tree.cut)
                {
                    tree.fertilized = true;
                    actionState = ACTION_STATES.NORMAL;
                    useAction(ACTION_COST.SKILL);
                    skillUsed = true;
                    socket.emit("trees", roomId, trees);
                    return;
                }

                refreshPickTreeButton();
                refreshCutTreeButton();
            }
        });

        if(infoSelected) return;

        // past this point: nothing was clicked

        if(actionState != ACTION_STATES.NORMAL)
        {
            actionState = ACTION_STATES.NORMAL;
            refreshSkillButton();
        }

        if(useItem)
        {
            infoSelected = prevSelected;
            return;
        }

        if(assigningVillager)
        {
            finishAssign(null);
            infoSelected = prevSelected;
            return;
        }

        if(heldItemStack)
        {
            heldItemStack = null;
            infoSelected = prevSelected;
            return;
        }
    }

    if(getActiveWindow() == "inventory")
    {
        if(!isCurrentTurn() || lootAmount > 0) return;

        if(buttonClick(buttons.sellItem))
        {
            inventoryState = INVENTORY_STATES.SELLING;
            refreshInventoryButtons();
            playClickSound();
            return;
        }

        if(buttonClick(buttons.upgradeMaterial))
        {
            inventoryState = INVENTORY_STATES.UPGRADING;
            refreshInventoryButtons();
            return;
        }

        for(let i = 0; i < inventory.length; i++)
        {
            const obj = {
                interactBox: {
                    x: 16*(11 + (i % 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN),
                    y: 16*(9 + Math.floor(i / 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN),
                    width: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN),
                    height: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN)
                }
            };

            if(mouseInteract(obj))
            {
                if(inventoryState == INVENTORY_STATES.NORMAL)
                {
                    heldItemStack = inventory[i];
                    closeInventory();
                }
                else if(inventoryState == INVENTORY_STATES.SELLING && inventory[i].item.type == "food")
                {
                    sellItem(inventory[i]);
                    playClickSound();
                    return;
                }
                else if(inventoryState == INVENTORY_STATES.UPGRADING && inventory[i].item.type == "material" && !inventory[i].item.upgraded)
                {
                    upgradeMaterial(inventory[i]);
                    playClickSound();
                }
            }
        }

        if(inventoryState != INVENTORY_STATES.NORMAL)
        {
            inventoryState = INVENTORY_STATES.NORMAL;
            refreshInventoryButtons();
        }
    }

    if(getActiveWindow() == "daily_loot")
    {
        let lootBoxWidth = 16*(2 + Math.min(dailyLoot.length, 8) * INVENTORY_BOX_SIZE);

        for(let i = 0; i < dailyLoot.length; i++)
        {
            if(dailyLoot[i])
            {
                const obj = {
                    interactBox: {
                        x: 16*(22 + (i % 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN) - lootBoxWidth/2,
                        y: 16*(9 + Math.floor(i / 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN),
                        width: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN),
                        height: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN)
                    }
                };

                if(mouseInteract(obj))
                {
                    collectLoot(i);
                    playClickSound();
                    break;
                }
            }
        }
    }

    if(getActiveWindow() == "shop")
    {
        for(let i = 0; i < shop.length; i++)
        {
            if(isCurrentTurn() && mouseInteract(shop[i]))
            {
                purchase(shop[i]);
                playClickSound();
                break;
            }
        }
    }
}

function onKeyDown(e)
{
    if(getActiveWindow() == "notification") return;

    switch(e.key.toLowerCase())
    {
        case 'e':               // inventory
        {
            if(getActiveWindow() == "inventory")
                closeInventory();
            else
                openInventory();

            break;
        }
        case "escape":          // close menus
        {
            closeInventory();
            closeShop();
            break;
        }
        case "shift":
        {
            displayHappiness = true;
            break;
        }
        default:
            break;
    }
}

function onKeyUp(e)
{
    if(getActiveWindow() == "notification") return;

    switch(e.key.toLowerCase())
    {
        case "shift":
            displayHappiness = false;
            break;
        default:
            break;
    }
}

function onMouseDown(e)
{
    if(e.button == 2) // right click
    {
        if(isCurrentTurn() && getActiveWindow() == "main")
        {
            for(let i = 0; i < villagers.length; i++)
            {
                if(mouseInteract(villagers[i]))
                {
                    movingVillager = villagers[i];
                    break;
                }
            }
        }
    }
}

function onMouseUp(e)
{
    if(e.button == 2)
    {
        // move villager
        if(isCurrentTurn() && movingVillager)
            moveVillager();

        movingVillager = null;
    }
}

function playClickSound()
{
    if(!soundOn) return;
    
    audio.click.currentTime = 0;
    audio.click.play();
}

// main ////////////////////////////////////////////////////////////////

export function init()
{
    canvas.width = img.background.width * SCALE;
    canvas.height = img.background.height * SCALE;

    audio.bgm.currentTime = 0;
    if(musicOn)
        audio.bgm.play();

    ctx.imageSmoothingEnabled = false;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    canvas.addEventListener("click", onClick);
    canvas.addEventListener("mousedown", onMouseDown);
    canvas.addEventListener("mouseup", onMouseUp);
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);

    buttons.help.enabled = true;
    currentTurn = 0;
    actionPoints = 0;
    skillUsed = false;

    day = 0;
    season = "";
    nextSeason = "";
    daysUntilNextSeason = 0;

    event = null;
    nextEvent = null;

    budget = 0;

    villagers = [];
    paths = [];
    movingVillager = null;

    facilities = {};
    farm = [];

    treesUnlocked = false;
    trees = [];

    shop = [];

    dailyLoot = [];
    lootAmount = 0;

    upgrades = 0;

    healChances = 0;
    reputation = 0;
    displayHappiness = false;

    cropGrowthModifier = 0;
    priceMultiplier = 1;

    actionState = ACTION_STATES.NORMAL;
    inventoryState = INVENTORY_STATES.NORMAL;

    heldItemStack = null;
    assigningVillager = null;

    infoSelected = null;
    labelSelected = null;

    windowStack = ["main"];

    notifications = [];
    currentNotif = null;

    cloudShadows = [];

    if(role == "scientist")
        ACTION_COST.SKILL = 4;

    else if(role == "farmer")
        ACTION_COST.SKILL = 8;

    else if(role == "sociologist" || role == "doctor")
        ACTION_COST.SKILL = 3;
}

export function exit()
{
    canvas.removeEventListener("click", onClick);
    canvas.removeEventListener("mousedown", onMouseDown);
    canvas.removeEventListener("mouseup", onMouseUp);
    window.removeEventListener("keydown", onKeyDown);
    window.removeEventListener("keyup", onKeyDown);

    audio.bgm.pause();
}

function isCurrentTurn()    // bool
{
    return players[currentTurn].id == socketId;
}

function triggerNotifications()
{
    if(getActiveWindow() == "notification" || sm.currentScene != sm.SCENE.game) return;

    if(notifications.length > 0)
    {
        if(soundOn)
        {
            audio.notification.currentTime = 0;
            audio.notification.play();
        }

        windowStack.push("notification");
        currentNotif = notifications[0];
        setTimeout(() => {
            currentNotif = null;
            notifications.shift();
            if(getActiveWindow() == "notification") windowStack.pop();
            
            notificationBox.x = 16*34;
            notificationBox.width = 0;
            triggerNotifications();
        }, currentNotif.duration);
    }
    else
    {
        if(day > 1 && villagers.length < (maxVillagers - 3))
            gameOver("GAME OVER: More than 3 villagers have left the village");
    }
}

function getActiveWindow()
{
    return windowStack[windowStack.length - 1];
}

function selectedInfoType(infoType)     // bool
{
    return infoSelected && infoSelected.infoType == infoType;
}

function endTurn()
{
    closeInventory();
    socket.emit("end_turn", roomId);
}

function openInventory()
{
    if(getActiveWindow() != "inventory")
    {
        closeShop();
        closeRole();
        windowStack.push("inventory");
        heldItemStack = null;
        assigningVillager = null;

        buttons.assignVillager.enabled = false;
        buttons.healVillager.enabled = false;

        refreshInventoryButtons();
    }
}

function closeInventory()
{
    if(getActiveWindow() == "inventory")
    {
        windowStack.pop();

        refreshAssignButton();
        refreshHealButton();

        inventoryState = INVENTORY_STATES.NORMAL;
        refreshInventoryButtons();
    }
}

function openRole()
{
    if(getActiveWindow() != "role")
    {
        closeShop();
        closeInventory();
        windowStack.push("role");
        heldItemStack = null;
        assigningVillager = null;

        buttons.assignVillager.enabled = false;
        buttons.healVillager.enabled = false;
    }
}

function closeRole()
{
    if(getActiveWindow() == "role")
    {
        windowStack.pop();
        refreshAssignButton();
        refreshHealButton();
    }
}

function openShop()
{
    if(getActiveWindow() != "shop")
    {
        closeInventory();
        closeRole();
        windowStack.push("shop");
        heldItemStack = null;
        assigningVillager = null;

        buttons.assignVillager.enabled = false;
        buttons.healVillager.enabled = false;
    }
}

function closeShop()
{
    if(getActiveWindow() == "shop")
    {
        windowStack.pop();
        refreshAssignButton();
        refreshHealButton();
    }
}

function setLabel(obj)
{
    labelSelected = obj;
}

function getSellPrice()     // int
{
    return 10 + (facilities["housing"].level - 1) * 5;
}

function useAction(amount)
{
    // return; // debug
    actionPoints -= amount;

    refreshAssignButton();
    refreshCutTreeButton();
    refreshHealButton();
    refreshPickTreeButton();
    refreshUpgradeFacilityButton();
    refreshSkillButton();

    if(amount == ACTION_COST.SKILL)
        socket.emit("actions", roomId, `Used ${role} skill.`);

    buttons.harvestCrop.enabled = actionPoints >= ACTION_COST.HARVEST_CROP;
}

function useSkill()
{
    switch(role)
    {
        case "chief":
        {
            reputation++;
            socket.emit("reputation", roomId, reputation);
            useAction(ACTION_COST.SKILL);
            skillUsed = true;
        }
        break;
        case "doctor":
        {
            actionState = ACTION_STATES.SELECT_VILLAGER;
            buttons.skill.enabled = false;
        }
        break;
        case "scientist":
        {
            useAction(ACTION_COST.SKILL);
            skillUsed = true;
        }
        break;
        case "sociologist":
        {
            actionState = ACTION_STATES.SELECT_VILLAGER;
            buttons.skill.enabled = false;
        }
        break;
        case "farmer":
        {
            actionState = ACTION_STATES.SELECT_FARMLAND;
            buttons.skill.enabled = false;
        }
        break;
        case "engineer":
        {
            socket.emit("engineer_skill", inventory);
            useAction(ACTION_COST.SKILL);
            skillUsed = true;
        }
        break;
        default:
            break;
    }
}

function plantCrop(farmland)
{
    farmland.crop = heldItemStack.item;
    farmland.daysLeft = (role == "farmer" ? CROP_GROWTH_TIME - 1 : CROP_GROWTH_TIME) + cropGrowthModifier;
    farmland.label = farmland.daysLeft + " days";
    socket.emit("farm", roomId, farm);
    socket.emit("actions", roomId, "Planted crop.");

    useAction(ACTION_COST.PLANT_CROP);

    useItem(heldItemStack);
}

function harvestCrop()
{
    let farmland = infoSelected;
    let amount = Math.floor(Math.random() * (farmland.amount - 2 + 1)) + 2 + (farmland.fertilized ? FERTILIZED_BONUS : 0);

    giveItem(farmland.crop.food, amount);

    let seedCount = 0;
    for(let i = 0; i < amount; i++)
    {
        if(Math.random() < HARVEST_SEED_CHANCE)
            seedCount++;
    }

    if(seedCount > 0)
        giveItem(farmland.crop, seedCount);

    farmland.crop = null;
    farmland.label = "empty";
    socket.emit("farm", roomId, farm);
    socket.emit("actions", roomId, "Harvested crop.");

    useAction(ACTION_COST.HARVEST_CROP);
    infoSelected = null;
}

function pickTree()
{
    useAction(ACTION_COST.PICK_TREE);
    let tree = infoSelected;
    socket.emit("pick_tree", roomId, tree.id);
    socket.emit("actions", roomId, "Picked apple from tree.");
}

function cutTree()
{
    useAction(ACTION_COST.CUT_TREE);
    let tree = infoSelected;
    socket.emit("cut_tree", roomId, tree.id);
    socket.emit("actions", roomId, "Cut tree.");
}

function giveItem(item, amount)
{
    if(amount <= 0) return;

    for(let i = 0; i < inventory.length; i++)
    {
        if(inventory[i].item.id == item.id)
        {
            if(inventory[i].item.type == "material" && inventory[i].item.upgraded != item.upgraded)
                continue;

            inventory[i].amount += amount;
            saveInventory();
            return;
        }
    }

    inventory.push(new ItemStack(item, amount));

    saveInventory();
}

function startAssign()
{
    heldItemStack = null;

    assigningVillager = infoSelected;
    buttons.assignVillager.enabled = false;
}

function finishAssign(facility)
{
    if(facility == facilities["power"] && facilities["power"].assignedVillagers.length > 0)
    {
        assigningVillager = null;
        buttons.assignVillager.enabled = true;
        return;
    }

    // villager is assigned to same facility
    if(facility && assigningVillager.currentTask == facility.label)
    {
        assigningVillager = null;
        buttons.assignVillager.enabled = true;
        return;
    }

    // remove villager from current assigned facility
    let oldFacility = null;

    if(assigningVillager.currentTask)
    {
        oldFacility = facilities[assigningVillager.currentTask];

        for(let i = 0; i < oldFacility.assignedVillagers.length; i++)
        {
            if(oldFacility.assignedVillagers[i] == assigningVillager.name)
            {
                oldFacility.assignedVillagers.splice(i, 1);
                break;
            }
        }
    }

    if(facility)
    {
        assigningVillager.currentTask = facility.label;

        // add villager to new facility
        facilities[facility.label].assignedVillagers.push(assigningVillager.name);

        useAction(ACTION_COST.ASSIGN_VILLAGER);
    }
    else
        assigningVillager.currentTask = null;

    socket.emit("assign_villager", roomId, assigningVillager, oldFacility, facility);

    assigningVillager = null;
    refreshAssignButton();
}

function isHoldingFood()        // bool
{
    return heldItemStack && heldItemStack.item.type == "food";
}

function feedVillager(villager)
{
    villager.fed = true;

    if(heldItemStack.item.id == villager.favoriteFood)
        villager.hunger = 5;
    else
        villager.hunger = Math.min(villager.hunger + 1, 4);

    if(heldItemStack.item.id == "apple")
        villager.happiness += APPLE_HAPPINESS_BOOST;

    socket.emit("villager", roomId, villager);

    useItem(heldItemStack);
}

function healVillager()
{
    let villager = infoSelected;
    villager.sick = false;

    useAction(ACTION_COST.HEAL_VILLAGER);

    if(healChances > 0)
        healChances--;
    else
        spendBudget(Math.floor(HEAL_VILLAGER_COST * priceMultiplier));

    refreshHealButton();

    socket.emit("villager", roomId, villager);
}

function moveVillager()
{
    let pathX = Math.floor(mouse.x / (16*SCALE)) - 8;
    let pathY = Math.floor(mouse.y / (16*SCALE));

    if(pathY >= 0 && pathY <= 21 && pathX >= 0 && pathX <= 25 && paths[pathY][pathX] != 'x')
    {
        paths[movingVillager.position.y][movingVillager.position.x] = '-';

        movingVillager.position.x = pathX;
        movingVillager.position.y = pathY;
        movingVillager.interactBox.x = pathX * 16 + 128;
        movingVillager.interactBox.y = pathY * 16;

        paths[pathY][pathX] = 'x';

        socket.emit("move_villager", roomId, movingVillager, paths);
    }
}

function useMaterial(facility)
{
    if(facility.progress < facility.progressMax && facility.level < 5 && actionPoints >= ACTION_COST.USE_MATERIAL)
    {
        facility.progress += heldItemStack.item.progress;
        if(facility.progress > facility.progressMax)
            facility.progress = facility.progressMax;

        useItem(heldItemStack);
        socket.emit("facility", roomId, facility);
        socket.emit("actions", roomId, `Used ${heldItemStack.item.name} on ${facility.label}.`);

        useAction(ACTION_COST.USE_MATERIAL);
    }
}

function useItem(itemStack)
{
    itemStack.amount--;

    if(itemStack.amount == 0)
    {
        // remove item from inventory
        const index = inventory.indexOf(itemStack);
        inventory.splice(index, 1);

        if(itemStack == heldItemStack) heldItemStack = null;
    }

    saveInventory();
}

function saveInventory()
{
    let prevGame = JSON.parse(localStorage.prevGame);
    prevGame.inventory = inventory;
    localStorage.prevGame = JSON.stringify({roomId, socketId, inventory});
}

function sellItem(itemStack)
{
    useItem(itemStack);
    spendBudget(-getSellPrice());
}

function upgradeMaterial(itemStack)
{
    spendBudget(UPGRADE_MATERIAL_COST);

    let success = getUpgradeSuccessChance();

    if(Math.random() < success)
    {
        let newItem = Object.assign({}, itemStack.item);
        newItem.name += "";
        newItem.progress = newItem.upgradedProgress;
        newItem.upgraded = true;

        useItem(itemStack);
        giveItem(newItem, 1);

        socket.emit("actions", roomId, `Upgrade ${itemStack.item.name} succeeded.`);
    }
}

function getUpgradeSuccessChance()  // float
{
    if(difficulty === 'speed') {
        switch(facilities["education"].level)
        {
            case 1: return 0.7;
            case 2: return 0.85;
            case 3: return 1.0;
            default: return -1;
        }
    } else {
        switch(facilities["education"].level)
        {
            case 1: return 0.5;
            case 2: return 0.6;
            case 3: return 0.7;
            case 4: return 0.8;
            case 5: return 1.0;
            default: return -1;
        }
    }
}

function spendBudget(amount)
{
    budget -= amount;
    socket.emit("budget", roomId, budget);
}

function collectLoot(index)
{
    giveItem(dailyLoot[index], 1);
    dailyLoot[index] = null;
    lootAmount--;

    if(lootAmount <= 0)
    {
        windowStack.pop();
        buttons.endTurn.enabled = true;
    }
}

function purchase(shopItem)
{
    let price = Math.floor(shopItem.price * priceMultiplier);

    if(budget < price) return;

    socket.emit("budget", roomId, budget - price);
    socket.emit("purchase", roomId, socketId, shopItem);
}


// refresh ////////////////////////////////////////////////////////////////

function refreshTrees()
{
    for(let i = 0; i < trees.length; i++)
    {
        trees[i].interactBox.x = 16 * ((i*(8 / trees.length)) + 23 + (1 - trees.length / 8));
        trees[i].interactBox.width = 16;

        if(treesUnlocked)
        {
            trees[i].label = "tree";

            trees[i].interactBox.y = 16 * 2.5;
            trees[i].interactBox.height = 24;
        }
        else
        {
            trees[i].label = "?";

            trees[i].interactBox.y = 16 * 3;
            trees[i].interactBox.height = 16;
        }
    }
}

function refreshInventoryButtons()
{
    let enable = isCurrentTurn() && getActiveWindow() == "inventory" && inventoryState == INVENTORY_STATES.NORMAL;

    buttons.sellItem.enabled = enable;
    buttons.upgradeMaterial.enabled = enable && role == "engineer" && budget >= UPGRADE_MATERIAL_COST;
}

function refreshShop()
{
    for(let i = 0; i < shop.length; i++)
    {
        shop[i].interactBox.x = 16*(16 + (Math.floor(i/5) * 10));
        shop[i].interactBox.y = 16*(10+((i%5)*2));
        shop[i].interactBox.width = 16*4;
        shop[i].interactBox.height = 16*1.5;
    }
}

function refreshAssignButton()
{
    buttons.assignVillager.enabled = role == "chief" && isCurrentTurn() && actionPoints >= ACTION_COST.ASSIGN_VILLAGER;
}

function refreshHealButton()
{
    buttons.healVillager.enabled = false;

    let cost = Math.floor(HEAL_VILLAGER_COST * priceMultiplier);

    if((rolesPresent["doctor"] || npcPresent["doctor"]) && healChances > 0)
        buttons.healVillager.text = `heal (${healChances})`;
    else
        buttons.healVillager.text = `heal ($${cost})`;

    if(!isCurrentTurn() || !selectedInfoType("villager") || actionPoints < ACTION_COST.HEAL_VILLAGER)
        return;

    if(infoSelected.sick)
    {
        buttons.healVillager.enabled = healChances > 0 || budget >= cost;
    }
}

function refreshUpgradeFacilityButton()
{
    buttons.upgradeFacility.enabled = false;
    
    if(isCurrentTurn() && selectedInfoType("facility") && infoSelected.progress == infoSelected.progressMax && actionPoints >= ACTION_COST.UPGRADE_FACILITY)
    {
        let enable = true;

        if(infoSelected.label == "power")
        {
            enable = infoSelected.level == 1;
        }
        else
        {
            if(infoSelected.level >= 5)
                enable = false;
            else
            {
                Object.values(infoSelected.cost).forEach(amount => {
                    if(amount > 0)
                        enable = false;
                });
            }
        }

        buttons.upgradeFacility.enabled = enable;
    }
}

function refreshPickTreeButton()
{
    if(!isCurrentTurn() || !selectedInfoType("tree") || actionPoints < ACTION_COST.PICK_TREE)
    {
        buttons.pickTree.enabled = false;
        return;
    }

    buttons.pickTree.enabled = infoSelected.daysLeft == 0 && !infoSelected.cut;
}

function refreshCutTreeButton()
{
    if(!isCurrentTurn() || !selectedInfoType("tree") || actionPoints < ACTION_COST.CUT_TREE)
    {
        buttons.cutTree.enabled = false;
        return;
    }

    buttons.cutTree.enabled = !infoSelected.cut;
}

function refreshSkillButton()
{
    buttons.skill.enabled = isCurrentTurn() && actionState == ACTION_STATES.NORMAL && actionPoints >= ACTION_COST.SKILL;
}


// drawing ////////////////////////////////////////////////////////////////

function getTextColor(text)
{
    switch(text)
    {
        case "water":       return "#33CCFF";
        case "farming":     return "#00CC33";
        case "education":   return "#FFCC66";
        case "housing":     return "#FF6666";
        case "power":       return "#FFFF00";

        case "most eff:":
        case "most fav:":
            return "gold";

        case "least eff:":
        case "least fav:":
            return "mediumpurple";

        case "immune":
            if(selectedInfoType("villager"))
                return infoSelected.immune ? "aqua" : null;

        case "(none)":
            return "gray";

        default:
            return null;
    }
}

function drawLabel()
{
    if(labelSelected == null) return;

    let obj = labelSelected;

    let labelColor = "white";

    if(obj.infoType == "facility")
        labelColor = getTextColor(obj.label);

    if(obj.infoType == "villager")
        labelColor = obj.sick ? "rgb(0,191,0)" : "white";

    drawTooltip(obj.interactBox, obj.label, labelColor);
}

function drawItemLabel(interactBox, item)
{
    ctx.font = '16px Kenney Mini Square';
    ctx.textAlign = "center";
    ctx.textBaseline = "top";

    let nameRect = ctx.measureText(item.name);
    let typeRect = ctx.measureText(item.type);

    let textWidth = Math.max(nameRect.width, typeRect.width);
    let textHeight = nameRect.fontBoundingBoxAscent + nameRect.fontBoundingBoxDescent;
    let padding = 8;

    if(item.type == "material")
    {
        ctx.fillStyle = "black";
        ctx.fillRect(
            (interactBox.x + interactBox.width/2) * SCALE - textWidth/2 - padding,
            (interactBox.y * SCALE) - 60 - padding/2 - (textHeight + padding),
            textWidth + 2 * padding,
            (textHeight + padding) * 3);

        ctx.fillStyle = "white";
        ctx.fillText(item.name, (interactBox.x + interactBox.width/2) * SCALE, (interactBox.y * SCALE) - 84);
        ctx.fillStyle = item.upgraded ? "orange" : "gray";
        ctx.fillText("+" + item.progress, (interactBox.x + interactBox.width/2) * SCALE, (interactBox.y * SCALE) - 60);
        ctx.fillStyle = "dodgerblue";
        ctx.fillText(item.type, (interactBox.x + interactBox.width/2) * SCALE, (interactBox.y * SCALE) - 36);
    }
    else
    {
        ctx.fillStyle = "black";
        ctx.fillRect(
            (interactBox.x + interactBox.width/2) * SCALE - textWidth/2 - padding,
            (interactBox.y * SCALE) - 60 - padding/2,
            textWidth + 2 * padding,
            (textHeight + padding) * 2);

        ctx.fillStyle = "white";
        ctx.fillText(item.name, (interactBox.x + interactBox.width/2) * SCALE, (interactBox.y * SCALE) - 60);
        ctx.fillStyle = "dodgerblue";
        ctx.fillText(item.type, (interactBox.x + interactBox.width/2) * SCALE, (interactBox.y * SCALE) - 36);
    }
}

function drawTooltip(interactBox, text, color,textFont, modifyX, modifyY)
{
    if(modifyX == undefined) modifyX = 0;
    if(modifyY == undefined) modifyY = 0;
    ctx.font = textFont ? textFont : "16px Kenney Mini Square";

    // break up the text if it's too long
    const words = text.split(" ");
    const lines = [''];
    const maxLineWidth = 150; 
    let lineNum = 0;

    for(let i =0; i < words.length; i++){
        if(ctx.measureText(lines[lineNum] + words[i]).width <= maxLineWidth){
            lines[lineNum] += words[i] + ' ';
        }else{
            lineNum++;
            lines[lineNum] = '';
            i--;
        }
    }

    // find the longest line
    let textWidth = lines.reduce((maxWidth, line) => {
        const lineWidth = ctx.measureText(line).width;
        return Math.max(maxWidth, lineWidth);
    },0);

    let textRect = ctx.measureText(text);
    let lineHeight = textRect.fontBoundingBoxAscent + textRect.fontBoundingBoxDescent;
    let textHeight = (numLines) => numLines * lineHeight;

    let padding = 8;

    ctx.fillStyle = "black";

    // build the size of the background
    const x = (interactBox.x + interactBox.width/2) * SCALE - textWidth/2 - padding;
    const y = (interactBox.y * SCALE) - 32 - padding/2 - textHeight(lines.length-1);
    const width = textWidth + 2 * padding;
    const height = textHeight(lines.length) + padding;

    ctx.fillRect(
        x + modifyX,
        y + modifyY,
        width,
        height);

    ctx.fillStyle = color;

    // write text line by line
    for(let i =0; i< lines.length; i++){
        ctx.fillText(lines[i], 
            (interactBox.x + interactBox.width/2) * SCALE - textWidth/2 + modifyX, 
            (interactBox.y * SCALE) + (i * lineHeight) - 32 + modifyY - textHeight(lines.length - 1));
    }
}

function drawTooltips()
{
    // upgrade facility
    if(selectedInfoType("facility") && mouseInteract(buttons.upgradeFacility))
        drawTooltip(buttons.upgradeFacility.interactBox, `cost: ${ACTION_COST.UPGRADE_FACILITY}`, "magenta");

    // plant crop
    if(heldItemStack?.item.type == "seed")
    {
        for(let i = 0; !farm[i].locked; i++)
        {
            if(!farm[i].crop && mouseInteract(farm[i]))
            {
                setLabel(null);
                drawTooltip(farm[i].interactBox, `cost: ${ACTION_COST.PLANT_CROP}`, "magenta");
                break;
            }
        }   
    }

    // harvest crop
    if(selectedInfoType("farmland") && mouseInteract(buttons.harvestCrop))
        drawTooltip(buttons.harvestCrop.interactBox, `cost: ${ACTION_COST.HARVEST_CROP}`, "magenta");

    
    if(treesUnlocked)
    {
        // pick tree
        if(selectedInfoType("tree") && !infoSelected.cut && infoSelected.daysLeft == 0 && mouseInteract(buttons.pickTree))
            drawTooltip(buttons.pickTree.interactBox, `cost: ${ACTION_COST.PICK_TREE}`, "magenta");

        // cut tree
        if(selectedInfoType("tree") && !infoSelected.cut && mouseInteract(buttons.cutTree))
            drawTooltip(buttons.cutTree.interactBox, `cost: ${ACTION_COST.CUT_TREE}`, "magenta");
    }
    

    // assign villager
    if(selectedInfoType("villager") && mouseInteract(buttons.assignVillager))
        drawTooltip(buttons.assignVillager.interactBox, `cost: ${ACTION_COST.ASSIGN_VILLAGER}`, "magenta");

    // heal villager
    if(selectedInfoType("villager") && mouseInteract(buttons.healVillager))
        drawTooltip(buttons.healVillager.interactBox, `cost: ${ACTION_COST.HEAL_VILLAGER}`, "magenta");

    // use material
    if(heldItemStack?.item.type == "material")
    {
        let f = Object.values(facilities);
        for(let i = 0; i < f.length; i++)
        {
            if(mouseInteract(f[i]))
            {
                setLabel(null);
                drawTooltip(f[i].interactBox, `cost: ${ACTION_COST.USE_MATERIAL}`, "magenta");
                break;
            }
        }
    }

    // skill
    if(mouseInteract(buttons.skill))
        drawTooltip(buttons.skill.interactBox, `cost: ${ACTION_COST.SKILL}`, "magenta");

    // upgrade material
    if(role == "engineer" && getActiveWindow() == "inventory" && mouseInteract(buttons.upgradeMaterial))
        drawTooltip(buttons.upgradeMaterial.interactBox, `success: ${getUpgradeSuccessChance() * 100}%`, "cyan");
}

function drawVillagers()
{
    villagers.forEach(villager => {

        drawVillager(villager,
            villager.position.x * 16 + 128,
            villager.position.y * 16,
            1);


        // draw food popup

        if(isHoldingFood())
        {
            let obj = {
                interactBox: {
                    x: (villager.position.x * 16 + 128),
                    y: (villager.position.y * 16 - 22),
                    width: 16,
                    height: 16
                }
            };

            ctx.save();

            let canFeed = !villager.fed && villager.hunger < 5;

            // if villager can be fed
            if(canFeed)
            {
                if(mouseInteract(obj))
                {
                    ctx.fillStyle = "lightgray";
                    setLabel(null);
                }
                else
                    ctx.fillStyle = "white";
            }
            else
            {
                ctx.globalAlpha = 0.75;
                ctx.fillStyle = "gray";
            }
            
            ctx.fillRect(
                obj.interactBox.x * SCALE,
                obj.interactBox.y * SCALE,
                16*SCALE, 16*SCALE);

            ctx.drawImage(img[villager.favoriteFood],
                (villager.position.x * 16 + 128 + 2) * SCALE,
                (villager.position.y * 16 - 20) * SCALE,
                12*SCALE, 12*SCALE);

            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = "18px Kenney Mini Square";
            ctx.fillText(villager.hunger, (obj.interactBox.x + 8) * SCALE, (obj.interactBox.y + 8) * SCALE);

            if(canFeed)
            {
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    obj.interactBox.x * SCALE,
                    obj.interactBox.y * SCALE,
                    16*SCALE, 16*SCALE);
            }

            ctx.restore();
        }

        // draw happiness popup
        if(displayHappiness && role == "sociologist")
        {
            ctx.save();

            ctx.drawImage(img.heart,
                (villager.position.x * 16 + 128) * SCALE,
                (villager.position.y * 16) * SCALE,
                16*SCALE, 16*SCALE);

            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = "16px Kenney Mini Square";
            ctx.fillText(villager.happiness, (villager.position.x * 16 + 128 + 8) * SCALE, (villager.position.y * 16 + 6) * SCALE);

            ctx.restore();
        }

        // ctx.lineWidth = 4;
        // ctx.strokeStyle = "black";
        // ctx.strokeRect(
        //     villager.interactBox.x * SCALE,
        //     villager.interactBox.y * SCALE,
        //     villager.interactBox.width * SCALE,
        //     villager.interactBox.height * SCALE);

        if(getActiveWindow() == "main" && !isHoldingFood() && mouseInteract(villager))
            setLabel(villager);
    });
}

function drawPaths()
{
    if(!movingVillager) return;

    ctx.save();

    ctx.globalAlpha = 0.3;

    for(let i = 0; i < paths.length; i++)
    {
        for(let j = 0; j < paths[i].length; j++)
        {
            if(paths[i][j] == 'x')
                ctx.fillStyle = "red";
            else
                ctx.fillStyle = "white";

            ctx.fillRect(
                16 * (j + 8) * SCALE,
                16 * (i + 0) * SCALE,
                16 * SCALE, 16 * SCALE);
        }
    }

    ctx.globalAlpha = 0.5;

    
    let pathX = Math.floor(mouse.x / (16*SCALE));
    let pathY = Math.floor(mouse.y / (16*SCALE));

    if(pathY >= 0 && pathY <= 21 && pathX - 8 >= 0 && pathX - 8 <= 25)
    {
        ctx.fillStyle = "blue";
        ctx.fillRect(
            pathX * (16*SCALE),
            pathY * (16*SCALE),
            16*SCALE, 16*SCALE);
    }

    ctx.restore();
}

function drawFacilities()
{
    ctx.drawImage(img.facilityWater, 176 * SCALE, 112 * SCALE, img.facilityWater.width * SCALE, img.facilityWater.height * SCALE);
    ctx.drawImage(img.facilityEducation, 176 * SCALE, 240 * SCALE, img.facilityEducation.width * SCALE, img.facilityEducation.height * SCALE);
    ctx.drawImage(img.facilityHousing, 368 * SCALE, 240 * SCALE, img.facilityHousing.width * SCALE, img.facilityHousing.height * SCALE);

    if(Object.keys(facilities).length > 0)
    {
        // ctx.drawImage(facilities["power"].level > 1 ? img.powerOn : img.powerOff, 16*16*SCALE, 16*1*SCALE, img.powerOff.width * SCALE, img.powerOn.height * SCALE);
        
        ctx.drawImage(facilities["power"].level > 1 ? powerOnAnimation.getFrame() : img.powerOff, 16*16*SCALE, 16*1*SCALE, img.powerOff.width * SCALE, img.powerOn.height * SCALE);

        Object.values(facilities).forEach(facility => {
            if(getActiveWindow() == "main" && mouseInteract(facility))
                setLabel(facility);
        });
    }
}

function drawFarmland()
{
    farm.forEach(obj => {
        let farmImg = obj.locked ? img.farmlandLocked : img.farmland;
        if(obj.fertilized) farmImg = img.farmlandFertilized;

        ctx.drawImage(farmImg, obj.interactBox.x * SCALE, obj.interactBox.y * SCALE, 16 * SCALE, 16 * SCALE);

        if(obj.crop)
        {
            let cropImg = obj.daysLeft == 0 ? img[obj.crop.food.id] : img.plant;
            ctx.drawImage(cropImg, obj.interactBox.x * SCALE, obj.interactBox.y * SCALE, 16 * SCALE, 16 * SCALE);
        }

        if(heldItemStack && heldItemStack.item.type == "material")
            return;

        if(getActiveWindow() == "main" && !assigningVillager && !obj.locked && mouseInteract(obj))
            setLabel(obj);
    });
}

function drawTrees()
{
    trees.forEach(obj => {

        if(treesUnlocked)
        {
            let image = img.treeRipe;

            if(obj.cut)
                image = img.treeStump;
            else if(obj.daysLeft > 0)
                image = img.treeBare;
            else if(obj.fertilized)
                image = img.treeFertilized;

            ctx.drawImage(image, obj.interactBox.x * SCALE, (obj.interactBox.y - 8) * SCALE, 16 * SCALE, 32 * SCALE);
        }
        else
            ctx.drawImage(img.plant, obj.interactBox.x * SCALE, obj.interactBox.y * SCALE, 16 * SCALE, 16 * SCALE);


        if(getActiveWindow() == "main" && mouseInteract(obj))
            setLabel(obj);
    });
}

function drawEventEffects()
{
    if(!event) return;

    if(event.blocked) return;

    if(event.id == "cloudy_day")
    {
        ctx.globalAlpha = 0.25;
        cloudShadows.forEach(cloud => {
            ctx.drawImage(img.cloudShadows, 64*cloud.type, 0, 64, 64, cloud.x*SCALE, cloud.y*SCALE, 64*SCALE, 64*SCALE);
        });
        ctx.globalAlpha = 1;
    }
    else if(event.id == "flood")
    {
        ctx.globalAlpha = 0.6;
        cloudShadows.forEach(cloud => {
            ctx.drawImage(img.puddles, 16*cloud.type, 0, 16, 16, cloud.x*SCALE, cloud.y*SCALE, 32*SCALE, 32*SCALE);
        });
        ctx.globalAlpha = 1;
    }
    else if(event.id == "rainy_day")
    {
        ctx.globalAlpha = 0.25;
        let image = rainAnimation.getFrame();
        ctx.drawImage(image, 0, 0, image.width/2, image.height/2, 16*8*SCALE, 0, image.width*SCALE, image.height*SCALE);
        ctx.globalAlpha = 1;
    }
}

function drawTitleBar()
{
    ctx.save();

    ctx.textAlign = "left";
    ctx.font = "20px Kenney Mini Square";
    ctx.textBaseline = "middle";
    ctx.lineWidth = 4;

    let currentTurnText = "current turn:   " + players[currentTurn].name;
    let x = 16*8.5*SCALE;
    let y = 16*0.5*SCALE;
    ctx.strokeStyle = "white";
    ctx.fillStyle = "black";
    ctx.strokeText(currentTurnText, x, y);
    ctx.fillText(currentTurnText, x, y);
    
    ctx.textAlign = "right";
    let fleeText = "".repeat(Math.max(Math.min(maxVillagers - villagers.length, 4), 0));
    let reputationText = fleeText + "        " + "   " + reputation + "        " + "   " + upgrades;
    x = 16*33.5*SCALE;
    y = 16*0.5*SCALE;
    ctx.strokeStyle = "white";
    ctx.strokeText(reputationText, x, y);
    ctx.fillStyle = "black";
    ctx.fillText(reputationText, x, y);

    ctx.restore();
}

function drawInfoPanel()
{
    ctx.font = '20px Kenney Mini Square';
    ctx.fillStyle = "sienna";
    ctx.textAlign = "center";
    ctx.fillText(role, 16*4*SCALE, 16*1*SCALE);
    ctx.textAlign = "left";

    if(!infoSelected) return;

    switch(infoSelected.infoType)
    {
        case "villager":
        {
            let villager = infoSelected;

            drawVillager(villager, 3*16, 2.5*16, 2);
            ctx.font = '32px Kenney Mini Square';
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.fillText(villager.name, 16*4*SCALE, 16*6*SCALE);

            ctx.beginPath();
            ctx.roundRect(16*0.5*SCALE, 16*7.75*SCALE, 16*7*SCALE, 16*9.5*SCALE, 4*SCALE);
            ctx.fill();

            ctx.font = '16px Kenney Mini Square';

            let textLeft = [
                "status:",
                "happiness:",
                "hunger:",
                "most eff:",
                "most fav:",
                "least eff:",
                "least fav:",
                "favorite:"
            ];

            let textRight = [
                villager.sick ? "sick" :
                    villager.immune ? "immune" : "healthy",
                (role == "sociologist" || npcPresent["sociologist"] ? villager.happiness : "?") + " / 100",
                villager.hunger + " / 5",
                villager.mostEffectiveTask,
                villager.mostFavoriteTask,
                (villager.leastEffectiveTask == "") ? "(none)" : villager.leastEffectiveTask,
                (villager.leastFavoriteTask == "") ? "(none)" : villager.leastFavoriteTask,
                villager.favoriteFood
            ];  

            // ctx.fillStyle = "white";
            for(let i = 0; i < textLeft.length; i++)
            {
                ctx.fillStyle = getTextColor(textLeft[i]) || "white";
                ctx.textAlign = "left";
                ctx.fillText(textLeft[i], 16 * SCALE, 16 * (i * 0.75 + 8) * SCALE);

                ctx.fillStyle = getTextColor(textRight[i]) || "white";
                ctx.textAlign = "right";
                ctx.fillText(textRight[i], 16 * 7 * SCALE, 16 * (i * 0.75 + 8) * SCALE);
            }

            ctx.textAlign = "right";
            ctx.fillStyle = getTextColor(villager.currentTask) || "gray";
            ctx.fillText(villager.currentTask ? villager.currentTask : "(none)", 16 * 7 * SCALE, 16*14.5*SCALE);
            ctx.textAlign = "left";
            ctx.fillStyle = "white";
            ctx.fillText("working:", 16 * SCALE, 16*14.5*SCALE);

            if(villager.quest)
            {
                ctx.fillText("quest:", 16 * SCALE, 16*15.75*SCALE);
                ctx.fillStyle = "goldenrod";
                ctx.fillText(villager.quest.description, 16 * SCALE, 16*16.5*SCALE);
            }
            
            drawButton(buttons.assignVillager);
            drawButton(buttons.healVillager);

            break;
        }
        case "facility":
        {
            let facility = infoSelected;

            ctx.font = "32px Kenney Mini Square";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";

            if(facility.label == "power")
            {
                ctx.fillText(facility.label, 16*4*SCALE, 16*7*SCALE);

                ctx.font = '16px Kenney Mini Square';
                ctx.fillText("level: " + facility.level, 16*4*SCALE, 16*9*SCALE);

                if(facility.level == 1)
                    ctx.fillText("progress: " + (+facility.progress.toFixed(2)) + " / " + facility.progressMax, 16*4*SCALE, 16*10*SCALE);
                else
                {
                    ctx.fillText("the next event", 16*4*SCALE, 16*10*SCALE);
                    ctx.fillText("will be blocked", 16*4*SCALE, 16*11*SCALE);
                }
            }
            else
            {
                ctx.fillText(facility.label, 16*4*SCALE, 16*7*SCALE);

                ctx.font = '16px Kenney Mini Square';
                ctx.fillText("level: " + facility.level, 16*4*SCALE, 16*9*SCALE);

                if(facility.level < 5)
                    ctx.fillText("progress: " + (+facility.progress.toFixed(2)) + " / " + facility.progressMax, 16*4*SCALE, 16*10*SCALE);
                else
                    ctx.fillText("max level", 16*4*SCALE, 16*10*SCALE);

                // ctx.fillStyle = facility.progress == facility.progressMax ? "black" : "gray";
                // ctx.fillText("upgrade cost", 16*4*SCALE, 16*9*SCALE);
                // let i = 0;
                // for (const [item, amount] of Object.entries(facility.cost)) {
                //     ctx.fillText(item + ": " + amount, 16*4*SCALE, 16*(10+i)*SCALE);
                //     i++;
                // }
            }

            ctx.fillStyle = "black";
            ctx.fillText("assigned villagers:", 16*4*SCALE, 16*13*SCALE);

            let rows = Math.floor(facility.assignedVillagers.length / 6);
            let remaining = facility.assignedVillagers.length % 6;

            for(let i = 0; i < facility.assignedVillagers.length; i++)
            {
                if(i < rows * 6)
                {
                    drawVillager(villagers.find(v => v.name == facility.assignedVillagers[i]),
                    16*(1 + (i % 6)),
                    16*(14.25 + Math.floor(i/6) * 1.5),
                    1);
                }
                else
                {
                    drawVillager(villagers.find(v => v.name == facility.assignedVillagers[i]),
                    16*(4 - remaining*0.5 + (i % 6)),
                    16*(14.25 + Math.floor(i/6) * 1.5),
                    1);
                }
            }

            if(facility.assignedVillagers.length == 0)
                ctx.fillText("(none)", 16*4*SCALE, 16*14*SCALE);

            if(!(facility.label == "power" && facility.level > 1))
                drawButton(buttons.upgradeFacility);
            
            ctx.textAlign = "left";
            break;
        }
        case "farmland":
        {
            let farmland = infoSelected;

            ctx.font = '32px Kenney Mini Square';
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.fillText("farmland", 16*4*SCALE, 16*8*SCALE);

            if(farmland.crop)
            {
                ctx.drawImage(img[farmland.crop.food.id],
                    16*3*SCALE,
                    16*5*SCALE,
                    16*2*SCALE,
                    16*2*SCALE);

                ctx.font = '16px Kenney Mini Square';
                ctx.fillText(farmland.crop.food.name, 16*4*SCALE, 16*10*SCALE);

                let cropMin = 2 + (farmland.fertilized ? FERTILIZED_BONUS : 0);
                let cropMax = farmland.amount + (farmland.fertilized ? FERTILIZED_BONUS : 0);
                ctx.fillText((cropMax > cropMin ? `+ ${cropMin}-` : "+ ") + cropMax, 16*4*SCALE, 16*11*SCALE);

                if(farmland.daysLeft == 0)
                {
                    ctx.fillText(farmland.label + " to harvest", 16*4*SCALE, 16*12*SCALE);
                    drawButton(buttons.harvestCrop);
                }
                else
                    ctx.fillText(farmland.label + " until mature", 16*4*SCALE, 16*12*SCALE);
            }
            else
            {
                ctx.font = '16px Kenney Mini Square';
                ctx.fillText(farmland.label, 16*4*SCALE, 16*10*SCALE);
            }

            if(farmland.fertilized)
            {
                ctx.fillStyle = "maroon";
                ctx.fillText("fertilized", 16*4*SCALE, 16*14*SCALE);
            }

            ctx.textAlign = "left";

            break;
        }
        case "tree":
        {
            let tree = infoSelected;

            ctx.save();

            ctx.font = '32px Kenney Mini Square';
            ctx.fillStyle = "black";
            ctx.textAlign = "center";

            if(treesUnlocked)
            {
                let image = img.treeRipe;
                let text = "days until ripe: " + tree.daysLeft;

                if(tree.cut)
                {
                    image = img.treeStump;
                    text = "cut";
                }
                else if(tree.daysLeft > 0)
                    image = img.treeBare;
                else if(tree.fertilized)
                    image = img.treeFertilized;

                ctx.drawImage(image, 16*3 * SCALE, 16*5 * SCALE, 16*2 * SCALE, 32*2 * SCALE);
                ctx.fillText(tree.label, 16*4*SCALE, 16*10*SCALE);

                ctx.font = '16px Kenney Mini Square';
                ctx.fillText(text, 16*4*SCALE, 16*12*SCALE);

                if(tree.fertilized)
                {
                    ctx.fillStyle = "maroon";
                    ctx.fillText("fertilized", 16*4*SCALE, 16*14*SCALE);
                }

                if(!tree.cut)
                {
                    if(tree.daysLeft == 0)
                        drawButton(buttons.pickTree);
                    drawButton(buttons.cutTree);
                }
            }
            else
            {
                ctx.font = "24px Kenney Mini Square";
                ctx.fillText("unidentified", 16*4*SCALE, 16*9*SCALE);
                ctx.fillText("plant", 16*4*SCALE, 16*10*SCALE);
            }

            ctx.restore();

            break;
        }
        default:
            break;
    }
}

function drawActionPanel()
{
    //ctx.drawImage(img.musicOn, 16*41*SCALE, 16*1*SCALE, 16*SCALE, 16*SCALE);
    drawButton(buttons.music);
    drawButton(buttons.sound);
    drawButton(buttons.inventory);
    drawButton(buttons.help);

    ctx.font = "24px Kenney Mini Square";
    ctx.fillStyle = "black";
    ctx.textAlign = "right";
    ctx.fillText("$" + budget, 16*41*SCALE, 16*1*SCALE);

    ctx.textAlign = "left";
    ctx.fillText("budget: ", 16*35*SCALE, 16*1*SCALE);
    ctx.fillText("day  " + day, 16*35*SCALE, 16*2*SCALE);
    ctx.fillText(season, 16*35*SCALE, 16*3*SCALE);

    ctx.font = "15px Kenney Mini Square";
    ctx.fillText(daysUntilNextSeason + " days until " + nextSeason, 16*35*SCALE, 16*4*SCALE);

    ctx.fillText("current event: ", 16*35*SCALE, 16*6*SCALE);
    if(event)
    {
        if(event.blocked)
            drawGrayscale(img["event_" + event.id], 16*35*SCALE, 16*7*SCALE, 16*6*SCALE, 16*2.5*SCALE);
        else
            ctx.drawImage(img["event_" + event.id], 16*35*SCALE, 16*7*SCALE, 16*6*SCALE, 16*2.5*SCALE);

        ctx.strokeRect(16*35*SCALE, 16*7*SCALE, 16*6*SCALE, 16*2.5*SCALE);
    }
    // ctx.fillText(event ? event.name : "", 16*35*SCALE, 16*7*SCALE);

    if(role == "scientist" && skillUsed)
    {
        ctx.fillText("next event: " + (nextEvent ? (nextEvent.type == 0 ? "good" : "bad") : "none"), 16*35*SCALE, 16*11*SCALE);
    }

    ctx.font = "20px Kenney Mini Square";
    ctx.fillText("action points:   " + actionPoints + "", 16*35*SCALE, 16*12*SCALE);


    drawButton(buttons.skill);
    drawButton(buttons.shop);
    drawButton(buttons.endTurn);
}

function drawLoot()
{
    if(getActiveWindow() != "daily_loot") return;

    ctx.save();

    ctx.fillStyle = "#FFDD55";

    let lootBoxWidth = 16*(2 + Math.min(dailyLoot.length, 8) * INVENTORY_BOX_SIZE);
    let lootBoxHeight = 16*(3+2.5*Math.ceil(dailyLoot.length/8));

    ctx.fillRect((16*21 - lootBoxWidth/2)*SCALE, 16*7*SCALE, lootBoxWidth*SCALE, lootBoxHeight*SCALE);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 4;
    ctx.strokeRect((16*21 - lootBoxWidth/2)*SCALE, 16*7*SCALE, lootBoxWidth*SCALE, lootBoxHeight*SCALE);

    ctx.font = '24px Kenney Mini Square';
    ctx.fillStyle = "black";
    ctx.fillText("daily loot", (16*22 - lootBoxWidth/2)*SCALE, 16*7.5*SCALE);

    ctx.textAlign = "right";
    ctx.fillText("pick " + lootAmount, (16*20 + lootBoxWidth/2)*SCALE, 16*7.5*SCALE);
    ctx.textAlign = "left";

    for(let i = 0; i < dailyLoot.length; i++)
    {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "black";
        ctx.fillStyle = "black";

        const obj = {
            interactBox: {
                x: 16*(22 + (i % 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN) - lootBoxWidth/2,
                y: 16*(9 + Math.floor(i / 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN),
                width: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN),
                height: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN)
            }
        };

        ctx.fillStyle = "white";
        ctx.fillRect(
            obj.interactBox.x * SCALE,
            obj.interactBox.y * SCALE,
            obj.interactBox.width * SCALE,
            obj.interactBox.height * SCALE);
        
        ctx.strokeRect(
            obj.interactBox.x * SCALE,
            obj.interactBox.y * SCALE,
            obj.interactBox.width * SCALE,
            obj.interactBox.height * SCALE);

        if(dailyLoot[i])
        {
            if(mouseInteract(obj))
            {
                ctx.fillStyle = "#EEEEEE";
                ctx.fillRect(
                    obj.interactBox.x * SCALE,
                    obj.interactBox.y * SCALE,
                    obj.interactBox.width * SCALE,
                    obj.interactBox.height * SCALE);

                drawItemLabel(obj.interactBox, dailyLoot[i]);
            }

            ctx.font = '24px Kenney Mini Square';
            ctx.fillStyle = "black";
            ctx.textAlign = "right";
            ctx.textBaseline = "bottom";

            let itemName = dailyLoot[i].id;
            ctx.drawImage(img[itemName],
                (16*(22 + (i % 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_SIZE/2 - 1) - lootBoxWidth/2)*SCALE,
                16*(9 + Math.floor(i / 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_SIZE/2 - 1)*SCALE,
                16*2*SCALE,
                16*2*SCALE);
        }
    }

    ctx.restore();
}

function drawInventory()
{
    if(getActiveWindow() != "inventory") return;

    ctx.save();

    ctx.fillStyle = "white";
    ctx.fillRect(16*10*SCALE, 16*7*SCALE, 16*22*SCALE, 16*13*SCALE);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 4;
    ctx.strokeRect(16*10*SCALE, 16*7*SCALE, 16*22*SCALE, 16*13*SCALE);

    ctx.font = '24px Kenney Mini Square';
    ctx.fillStyle = "black";
    ctx.fillText("inventory", 16*11*SCALE, 16*7.5*SCALE);

    drawButton(buttons.sellItem);
    if(role == "engineer") drawButton(buttons.upgradeMaterial);

    for(let i = 0; i < INVENTORY_SIZE; i++)
    {
        ctx.lineWidth = 1;
        ctx.strokeStyle = "black";
        ctx.fillStyle = "black";
        // ctx.strokeRect(
        //     16*(11 + (i % 8) * INVENTORY_BOX_SIZE)*SCALE,
        //     16*(9 + Math.floor(i / 8) * INVENTORY_BOX_SIZE)*SCALE,
        //     16*(INVENTORY_BOX_SIZE)*SCALE,
        //     16*(INVENTORY_BOX_SIZE)*SCALE);

        const obj = {
            interactBox: {
                x: 16*(11 + (i % 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN),
                y: 16*(9 + Math.floor(i / 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_MARGIN),
                width: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN),
                height: 16*(INVENTORY_BOX_SIZE - 2*INVENTORY_BOX_MARGIN)
            }
        };
        
        ctx.strokeRect(
            obj.interactBox.x * SCALE,
            obj.interactBox.y * SCALE,
            obj.interactBox.width * SCALE,
            obj.interactBox.height * SCALE);

        if(i < inventory.length)
        {
            let valid = false;
            switch(inventoryState)
            {
                case INVENTORY_STATES.NORMAL:
                    valid = true;
                    break;
                case INVENTORY_STATES.SELLING:
                    valid = inventory[i].item.type == "food";
                    break;
                case INVENTORY_STATES.UPGRADING:
                    valid = inventory[i].item.type == "material" && !inventory[i].item.upgraded;
                    break;
                default: break;
            }

            if(!valid)
            {
                ctx.fillStyle = "#888888";
                ctx.fillRect(
                    obj.interactBox.x * SCALE,
                    obj.interactBox.y * SCALE,
                    obj.interactBox.width * SCALE,
                    obj.interactBox.height * SCALE);
            }

            if(valid && mouseInteract(obj))
            {
                ctx.fillStyle = "#EEEEEE";
                ctx.fillRect(
                    obj.interactBox.x * SCALE,
                    obj.interactBox.y * SCALE,
                    obj.interactBox.width * SCALE,
                    obj.interactBox.height * SCALE);

                drawItemLabel(obj.interactBox, inventory[i].item);
            }

            ctx.font = '24px Kenney Mini Square';
            ctx.fillStyle = "black";
            ctx.textAlign = "right";
            ctx.textBaseline = "bottom";

            let itemName = inventory[i].item.id;
            ctx.drawImage(img[itemName],
                16*(11 + (i % 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_SIZE/2 - 1)*SCALE,
                16*(9 + Math.floor(i / 8) * INVENTORY_BOX_SIZE + INVENTORY_BOX_SIZE/2 - 1)*SCALE,
                16*2*SCALE,
                16*2*SCALE);

            ctx.strokeStyle = "white";
            ctx.strokeText(inventory[i].amount,
                16*(11 + ((i % 8) + 1) * INVENTORY_BOX_SIZE - 0.25)*SCALE,
                16*(9 + (Math.floor(i / 8) + 1) * INVENTORY_BOX_SIZE - 0.25)*SCALE);

            ctx.fillText(inventory[i].amount,
                16*(11 + ((i % 8) + 1) * INVENTORY_BOX_SIZE - 0.25)*SCALE,
                16*(9 + (Math.floor(i / 8) + 1) * INVENTORY_BOX_SIZE - 0.25)*SCALE);


            if(inventory[i].item.type == "material" && inventory[i].item.upgraded)
            {
                ctx.fillStyle = "orange";
                ctx.fillText("",
                    16*(11 + ((i % 8) + 1) * INVENTORY_BOX_SIZE - 0.25)*SCALE,
                    16*(9 + (Math.floor(i / 8) + 1) * INVENTORY_BOX_SIZE - 1.75)*SCALE);
            }

            if(inventory[i].item.type == "food" && inventoryState == INVENTORY_STATES.SELLING)
            {
                ctx.font = '18px Kenney Mini Square';
                ctx.fillStyle = "green";
                ctx.textBaseline = "top";
                ctx.textAlign = "left";

                ctx.strokeText("$" + getSellPrice(),
                    16*(11 + ((i % 8) + 0) * INVENTORY_BOX_SIZE + 0.25)*SCALE,
                    16*(9 + (Math.floor(i / 8) + 0) * INVENTORY_BOX_SIZE + 0.2)*SCALE);

                ctx.fillText("$" + getSellPrice(),
                    16*(11 + ((i % 8) + 0) * INVENTORY_BOX_SIZE + 0.25)*SCALE,
                    16*(9 + (Math.floor(i / 8) + 0) * INVENTORY_BOX_SIZE + 0.2)*SCALE);
            }
        }
    }

    ctx.restore();
}

function drawShop()
{
    if(getActiveWindow() != "shop") return;

    ctx.save();

    ctx.fillStyle = "white";
    ctx.fillRect(16*10*SCALE, 16*7*SCALE, 16*22*SCALE, 16*13*SCALE);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 4;
    ctx.strokeRect(16*10*SCALE, 16*7*SCALE, 16*22*SCALE, 16*13*SCALE);

    ctx.font = "24px Kenney Mini Square";
    ctx.fillStyle = "black";
    ctx.fillText("shop", 16*11*SCALE, 16*7.5*SCALE);

    ctx.font = "16px Kenney Mini Square";
    for(let i = 0; i < shop.length; i++)
    {
        ctx.fillStyle = "black";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(shop[i].name, 16*(11 + (Math.floor(i/5) * 10))*SCALE, 16*(10+((i%5)*2))*SCALE);
        
        if(mouseInteract(shop[i]))
        {
            ctx.fillStyle = "lightgray";
            ctx.fillRect(shop[i].interactBox.x*SCALE, shop[i].interactBox.y*SCALE, shop[i].interactBox.width*SCALE, shop[i].interactBox.height*SCALE);

            // draw shop item description
            ctx.fillStyle = "black";
            ctx.fillText(shop[i].description, 16*16*SCALE, 16*7.5*SCALE);
        }

        ctx.strokeStyle = "gray";
        ctx.strokeRect(shop[i].interactBox.x*SCALE, shop[i].interactBox.y*SCALE, shop[i].interactBox.width*SCALE, shop[i].interactBox.height*SCALE);

        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        let price = shop[i].price;

        if(priceMultiplier != 1)
        {
            ctx.fillStyle = "green";
            price = Math.floor(price * priceMultiplier);
        }

        ctx.fillText("$" + price, (shop[i].interactBox.x + shop[i].interactBox.width/2)*SCALE, (shop[i].interactBox.y + shop[i].interactBox.height/2)*SCALE);
    }

    ctx.restore();
}

function drawHeldItemStack()
{
    if(!heldItemStack) return;

    ctx.save();

    ctx.font = '24px Kenney Mini Square';
    ctx.fillStyle = "black";
    ctx.textAlign = "right";
    ctx.textBaseline = "bottom";

    let itemName = heldItemStack.item.id;
    ctx.drawImage(img[itemName],
        mouse.x - (16/2)*SCALE,
        mouse.y - (16/2)*SCALE,
        16*SCALE,
        16*SCALE);

    ctx.strokeStyle = "white";
    ctx.strokeText(heldItemStack.amount,
        mouse.x + (16)*SCALE,
        mouse.y + (16)*SCALE);

    ctx.fillText(heldItemStack.amount,
        mouse.x + (16)*SCALE,
        mouse.y + (16)*SCALE);

    ctx.restore();
}

function drawNotification()
{
    if(!currentNotif) return;

    ctx.fillStyle = "black";

    ctx.globalAlpha = 0.9;

    let nb = notificationBox;
    if(nb.x > 16*8)
    {
        nb.x -= 16;
        nb.width += 16;
    }
    ctx.fillRect(nb.x*SCALE, nb.y*SCALE, nb.width*SCALE, nb.height*SCALE);

    ctx.globalAlpha = 1;

    if(nb.x <= 16*8)
    {
        ctx.save();
        currentNotif.draw(ctx, SCALE);
        ctx.restore();
    }
}

function drawRoleDescription(){
    if(getActiveWindow() != "role") return;
    ctx.save();

    ctx.fillStyle = "white";
    ctx.fillRect(16*10*SCALE, 16*7*SCALE, 16*22*SCALE, 16*13*SCALE);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 4;
    ctx.strokeRect(16*10*SCALE, 16*7*SCALE, 16*22*SCALE, 16*13*SCALE);

    ctx.font = "24px o mono";
    ctx.fillStyle = "black";
    ctx.fillText("Role description", 16*11*SCALE, 16*7.5*SCALE);

    ctx.font = "16px o mono";

    switch(role){
        case 'doctor':
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Doctor", 16*11*SCALE, 16*10*SCALE);
            ctx.fillText("- Can heal 2 sick villagers per day for free", 16*11*SCALE, 16*11*SCALE);
            ctx.fillText("- Number of free heals increases per level of", 16*11*SCALE, 16*12*SCALE);
            ctx.fillText("  housing", 16*11*SCALE, 16*13*SCALE);
            ctx.fillText("- Other players receive 1 free heal per day", 16*11*SCALE, 16*14*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: makes a villager immune from sickness", 16*11*SCALE, 16*15*SCALE);
            ctx.fillText("  until the next mutation", 16*11*SCALE, 16*16*SCALE);
            break;
        case 'chief':
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Chief (required)", 16*11*SCALE, 16*10*SCALE);
            ctx.fillText("- The only role who can assign villagers to", 16*11*SCALE, 16*11*SCALE);
            ctx.fillText("  facilities", 16*11*SCALE, 16*12*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: village reputation increases by 1", 16*11*SCALE, 16*13*SCALE);
            ctx.fillText("- If reputation reaches 3, a new villager joins the", 16*11*SCALE, 16*14*SCALE);
            ctx.fillText("  village", 16*11*SCALE, 16*15*SCALE);
            break;
        case 'scientist':
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Scientist", 16*11*SCALE, 16*10*SCALE);
            ctx.fillText("- Makes apple trees available", 16*11*SCALE, 16*11*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: predicts if the next event is good or bad", 16*11*SCALE, 16*12*SCALE);
            break;
        case 'sociologist':
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Sociologist", 16*11*SCALE, 16*10*SCALE);
            ctx.fillText("- Can view villagers' exact happiness levels", 16*11*SCALE, 16*11*SCALE);
            ctx.fillText(" (hotkey = shift)", 16*11*SCALE, 16*12*SCALE)
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: eliminates a villager's least effective", 16*11*SCALE, 16*13*SCALE);
            ctx.fillText("  and least favorite task until the next mutation", 16*11*SCALE, 16*14*SCALE);
            break;
        case 'farmer':
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Farmer", 16*11*SCALE, 16*10*SCALE);
            ctx.fillText("- Seeds planted by the farmer grow faster by 1 day", 16*11*SCALE, 16*11*SCALE);
            ctx.fillText("- Can purchase seeds from the shop", 16*11*SCALE, 16*12*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: turns a piece of farmland into fertilized", 16*11*SCALE, 16*13*SCALE);
            ctx.fillText("  farmland", 16*11*SCALE, 16*14*SCALE)
            ctx.fillText("- Fertilized farmland produce more crops than", 16*11*SCALE, 16*15*SCALE);
            ctx.fillText("  normal", 16*11*SCALE, 16*16*SCALE);
            break;
        case 'engineer':
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Engineer", 16*11*SCALE, 16*10*SCALE);
            ctx.fillText("- Can upgrade materials with money, success chance", 16*11*SCALE, 16*11*SCALE);
            ctx.fillText("  increases with education level", 16*11*SCALE, 16*12*SCALE);
            ctx.fillText("- Upgraded materials increase more progress when", 16*11*SCALE, 16*13*SCALE);
            ctx.fillText("  used on facilities", 16*11*SCALE, 16*14*SCALE);
            ctx.fillText("- Can purchase steel from the shop", 16*11*SCALE, 16*15*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: converts every brick in inventory into", 16*11*SCALE, 16*16*SCALE);
            ctx.fillText("  steel", 16*11*SCALE, 16*17*SCALE);
            break;
    }
}

function drawToolTipIcons(){
    drawToolTipIcon(toolTips.skill);
    drawToolTipIcon(toolTips.shop);
    drawToolTipIcon(toolTips.event)
    drawToolTipIcon(toolTips.inventory)
    
    if(mouseInteract(toolTips.skill)){
        drawTooltip(toolTips.skill.interactBox, "Apply special skill to this turn", "white","18px o mono", -75);
    }
    
    if(mouseInteract(toolTips.shop)){
        drawTooltip(toolTips.shop.interactBox, "Hire additional experts, buy seeds (Farmer), and buy steel (Engineer)", "white", "18px o mono");
    }


    if(mouseInteract(toolTips.event)){
        drawTooltip(toolTips.event.interactBox, eventDescription, "white","18px o mono", -75);
    }

    if(mouseInteract(toolTips.inventory)){
        drawTooltip(toolTips.inventory.interactBox, "Inventory items for feeding villagers, planting seeds, and fixing facilities", "white", "18px o mono");
    }
}

export function draw()
{
    labelSelected = null;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img.background, 0, 0, img.background.width * SCALE, img.background.height * SCALE);

    drawFacilities();
    drawFarmland();
    drawTrees();
    drawVillagers();
    
    drawPaths();

    drawEventEffects();

    drawTitleBar();
    drawActionPanel();
    drawInfoPanel();

    drawLoot();
    drawInventory();
    drawShop();
    drawRoleDescription();

    drawTooltips();
    drawLabel();
    drawHeldItemStack();
    drawNotification();

    drawToolTipIcons();

    DayNotification.draw();


    if(sm.currentScene == sm.SCENE.game)
        requestAnimationFrame(draw);
}

================
File: client/scenes/SceneLobby.js
================
import * as global from "../global.js";
Object.entries(global).forEach(([name, exported]) => window[name] = exported);

import * as sm from "../src/SceneManager.js";
import { Button } from "../src/Button.js";

let ready = false;

let difficulty = "easy";

const buttons = {
    chief:          new Button(20*16, 4*16, 5.5*16, 1.5*16, "blue", "chief"),
    doctor:         new Button(26*16, 4*16, 5.5*16, 1.5*16, "blue", "doctor"),
    scientist:      new Button(20*16, 6*16, 5.5*16, 1.5*16, "blue", "scientist"),
    sociologist:    new Button(26*16, 6*16, 5.5*16, 1.5*16, "blue", "sociologist"),
    farmer:         new Button(20*16, 8*16, 5.5*16, 1.5*16, "blue", "farmer"),
    engineer:       new Button(26*16, 8*16, 5.5*16, 1.5*16, "blue", "engineer"),

    easy:           new Button(14*16, 0.5*16, 4*16, 1.5*16, "purple", "easy"),
    normal:         new Button(18.5*16, 0.5*16, 4*16, 1.5*16, "purple", "normal"),
    hard:           new Button(23*16, 0.5*16, 4*16, 1.5*16, "purple", "hard"),
    speed:          new Button(9.5*16, 0.5*16, 4*16, 1.5*16, "purple", "speed"),

    ready:          new Button(13.5*16, 20*16, 4*16, 1.5*16, "red", "ready"),
};

socket.on("refresh_lobby", (_players, _roomId) => {
    players = _players;
    roomId = _roomId;
});

socket.on("select_role", (_role) => {
    role = _role;

    if(role == "")
        buttons.ready.enabled = false;
    else
        buttons.ready.enabled = true;
});

socket.on("refresh_roles", (_rolesPresent) => {

    rolesPresent = _rolesPresent;

    for(const [role, present] of Object.entries(_rolesPresent))
        buttons[role].enabled = !present;
});

socket.on("select_difficulty", (_difficulty) => {
    difficulty = _difficulty;
});

socket.on("start_game", () => {
    localStorage.prevGame = JSON.stringify({roomId, socketId, inventory: []});

    sm.loadScene(sm.SCENE.game);
});

function onClick(e)
{
    if(ready) return;

    if(buttonClick(buttons.chief))          { socket.emit("select_role", roomId, "chief"); return; }
    if(buttonClick(buttons.doctor))         { socket.emit("select_role", roomId, "doctor"); return; }
    if(buttonClick(buttons.scientist))      { socket.emit("select_role", roomId, "scientist"); return; }
    if(buttonClick(buttons.sociologist))    { socket.emit("select_role", roomId, "sociologist"); return; }
    if(buttonClick(buttons.farmer))         { socket.emit("select_role", roomId, "farmer"); return; }
    if(buttonClick(buttons.engineer))       { socket.emit("select_role", roomId, "engineer"); return; }

    if(buttonClick(buttons.easy))           { socket.emit("select_difficulty", roomId, "easy"); return; }
    if(buttonClick(buttons.normal))         { socket.emit("select_difficulty", roomId, "normal"); return; }
    if(buttonClick(buttons.hard))           { socket.emit("select_difficulty", roomId, "hard"); return; }
    if(buttonClick(buttons.speed))          { socket.emit("select_difficulty", roomId, "speed"); return; }

    if(buttonClick(buttons.ready))
    {
        socket.emit("ready", roomId);
        ready = true;
        Object.values(buttons).forEach(button => button.enabled = false);

        return;
    }

    socket.emit("select_role", roomId, "");
}

export function init()
{
    canvas.width = 32*16 * SCALE;
    canvas.height = 22*16 * SCALE;

    ready = false;
    Object.values(buttons).forEach(button => button.enabled = true);
    buttons.ready.enabled = false;
    canvas.addEventListener("click", onClick);

    buttons.easy.enabled = isHost;
    buttons.normal.enabled = isHost;
    buttons.hard.enabled = isHost;
}

export function exit()
{
    canvas.removeEventListener("click", onClick);
}

export function draw()
{
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // ctx.drawImage(img.lobby, 0, 0, img.lobby.width * SCALE, img.lobby.height * SCALE);

    ctx.beginPath();
    ctx.rect(0, 0, canvas.width, canvas.height);
    ctx.stroke();
    
    ctx.font = "20px Arial Black";
    ctx.fillStyle = "black";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(("lobby: " + roomId).toUpperCase(), 1*16*SCALE, 1*16*SCALE);

    ctx.textAlign = "right";
    ctx.fillText((difficulty).toUpperCase(), canvas.width - (16*SCALE), 16*SCALE);

    ctx.textAlign = "left";
    ctx.font = "20px Kenney Mini Square";

    for(let i = 0; i < 6; ++i)
        ctx.fillText((i + 1) + ".", 4*16*SCALE, (4 + i*1.5)*16*SCALE);

    for(let i = 0; i < players.length; i++)
    {
        ctx.fillStyle = "black";
        ctx.fillText(players[i].name, 5*16*SCALE, (4 + i*1.5)*16*SCALE);
        ctx.fillStyle = "gray";
        ctx.fillText(players[i].role, 12*16*SCALE, (4 + i*1.5)*16*SCALE);

        if(players[i].ready)
        {
            ctx.fillStyle = "blue";
            ctx.fillText("ready", 1*16*SCALE, (4 + i*1.5)*16*SCALE);
        }
    }

    Object.values(buttons).forEach(button => drawButton(button));

    // role and difficulty descriptions
    switch(true)
    {
        case mouseInteract(buttons.speed):
            ctx.fillStyle = "purple";
            ctx.font = "20px o mono";
            ctx.fillText("Speed mode", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("8 villagers", 3*16*SCALE, 15*16*SCALE);
            ctx.fillText("6 days per season", 3*16*SCALE, 16*16*SCALE);
            ctx.fillText("Easier to upgrade building", 3*16*SCALE, 17*16*SCALE);
            ctx.fillText("More frequent changes in event with standard probability", 3*16*SCALE, 18*16*SCALE);
            ctx.fillText("Facilities provide better bonuses at lower levels", 3*16*SCALE, 19*16*SCALE);
            break;
        case mouseInteract(buttons.easy):
            ctx.fillStyle = "purple";
            ctx.font = "20px o mono";
            ctx.fillText("Easy difficulty", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("8 villagers", 3*16*SCALE, 15*16*SCALE);
            ctx.fillText("Standard event probabilities", 3*16*SCALE, 16*16*SCALE);
            break;
        case mouseInteract(buttons.normal):
            ctx.fillStyle = "purple";
            ctx.font = "20px o mono";
            ctx.fillText("Normal difficulty", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("10 villagers", 3*16*SCALE, 15*16*SCALE);
            ctx.fillText("Standard event probabilities", 3*16*SCALE, 16*16*SCALE);
            break;
        case mouseInteract(buttons.hard):
            ctx.fillStyle = "purple";
            ctx.font = "20px o mono";
            ctx.fillText("Normal difficulty", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("12 villagers", 3*16*SCALE, 15*16*SCALE);
            ctx.fillText("Bad events only", 3*16*SCALE, 16*16*SCALE);
            break;

        case mouseInteract(buttons.chief):
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Chief (required)", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("- The only role who can assign villagers to facilities", 3*16*SCALE, 15*16*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: village reputation increases by 1", 3*16*SCALE, 16*16*SCALE);
            ctx.fillText("- If reputation reaches 3, a new villager joins the village", 3*16*SCALE, 17*16*SCALE);
            break;
        case mouseInteract(buttons.doctor):
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Doctor", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("- Can heal 2 sick villagers per day for free", 3*16*SCALE, 15*16*SCALE);
            ctx.fillText("- Number of free heals increases per level of housing", 3*16*SCALE, 16*16*SCALE);
            ctx.fillText("- Other players receive 1 free heal per day", 3*16*SCALE, 17*16*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: makes a villager immune from sickness until the next mutation", 3*16*SCALE, 18*16*SCALE);
            break;
        case mouseInteract(buttons.scientist):
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Scientist", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("- Makes apple trees available", 3*16*SCALE, 15*16*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: predicts if the next event is good or bad", 3*16*SCALE, 16*16*SCALE);
            break;
        case mouseInteract(buttons.sociologist):
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Sociologist", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("- Can view villagers' exact happiness levels (hotkey = shift)", 3*16*SCALE, 15*16*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: eliminates a villager's least effective and least favorite", 3*16*SCALE, 16*16*SCALE);
            ctx.fillText("  task until the next mutation", 3*16*SCALE, 17*16*SCALE);
            break;
        case mouseInteract(buttons.farmer):
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Farmer", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("- Seeds planted by the farmer grow faster by 1 day", 3*16*SCALE, 15*16*SCALE);
            ctx.fillText("- Can purchase seeds from the shop", 3*16*SCALE, 16*16*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: turns a piece of farmland into fertilized farmland", 3*16*SCALE, 17*16*SCALE);
            ctx.fillText("- Fertilized farmland produce more crops than normal", 3*16*SCALE, 18*16*SCALE);
            break;
        case mouseInteract(buttons.engineer):
            ctx.fillStyle = "black";
            ctx.font = "20px o mono";
            ctx.fillText("Engineer", 3*16*SCALE, 14*16*SCALE);
            ctx.fillText("- Can upgrade materials with money, success chance increases with", 3*16*SCALE, 15*16*SCALE);
            ctx.fillText("  education level", 3*16*SCALE, 16*16*SCALE);
            ctx.fillText("- Upgraded materials increase more progress when used on facilities", 3*16*SCALE, 17*16*SCALE);
            ctx.fillText("- Can purchase steel from the shop", 3*16*SCALE, 18*16*SCALE);
            ctx.fillStyle = "cornflowerblue";
            ctx.fillText("- Skill: converts every brick in inventory into steel", 3*16*SCALE, 19*16*SCALE);
            break;

        default:
            break;
    }

    if(sm.currentScene == sm.SCENE.lobby)
        requestAnimationFrame(draw);
}

================
File: client/scenes/SceneMenu.js
================
import * as global from "../global.js";
Object.entries(global).forEach(([name, exported]) => window[name] = exported);

import {img} from "../assets.js";

import * as sm from "../src/SceneManager.js";
import { Button } from "../src/Button.js";
import { TextField } from "../src/TextField.js";
import { HelpModal } from "./HelpModal.js";  // Add this line


const buttons = {
    hostGame: new Button(4*16, 10*16, 6*16, 2*16, "pink", "host game"),
    reconnect: new Button(4*16, 13*16, 6*16, 2*16, "pink", "reconnect"),
    joinGame: new Button(16*16, 13*16, 6*16, 2*16, "pink", "join game"),
    help: new Button(16*11, 16*16, 4*16, 1.5*16, "pink", "help"),
    credits: new Button(16*11, 16*18, 4*16, 1.5*16, "pink", "credits"),
};


const textFields = {
    playerName: new TextField(8*16, 7*16, 10*16, 1*16, "player name", 20),
    roomCode: new TextField(16*16, 11*16, 6*16, 1*16, "room code", 4),
};

let selectedTextField = null;

let errorMessage = "";

let prevGame = null;

let helpModal = null;



function onClick(e)
{
    if(mouseInteract(textFields.playerName))
    {
        selectedTextField = textFields.playerName;
        return;
    }

    if(mouseInteract(textFields.roomCode))
    {
        selectedTextField = textFields.roomCode;
        return;
    }

    if(buttonClick(buttons.hostGame))
    {
        playerName = textFields.playerName.text;
        isHost = true;
        socket.emit("host_game", playerName);
        sm.loadScene(sm.SCENE.lobby);
        return;
    }

    if(buttonClick(buttons.reconnect))
    {
        // reconnect previous game
        if(prevGame)
            socket.emit("reconnect", prevGame.roomId, prevGame.socketId);
    }

    if(buttonClick(buttons.joinGame))
    {
        playerName = textFields.playerName.text;
        socket.emit("join_game", playerName, textFields.roomCode.text);
        return;
    }

    if(buttonClick(buttons.help))
        {
            if (!helpModal) {
                helpModal = new HelpModal();
            }
            helpModal.show();
            return;
        }

    if(buttonClick(buttons.credits))
    {
        sm.loadScene(sm.SCENE.credits);
        return;
    }

    selectedTextField = null;
}

function onKeyDown(e)
{
    if(sm.currentScene != sm.SCENE.menu) return;

    if(selectedTextField)
    {
        if(e.key.length == 1)
        {
            if(selectedTextField.text.length < selectedTextField.charLimit)
                selectedTextField.text += e.key;
            
            if(selectedTextField == textFields.roomCode) errorMessage = "";
        }
        else if(e.key == "Backspace")
        {
            selectedTextField.text = selectedTextField.text.substring(0, selectedTextField.text.length - 1);
            if(selectedTextField == textFields.roomCode) errorMessage = "";
        }

        buttons.hostGame.enabled = (textFields.playerName.text.length > 0);
        buttons.joinGame.enabled = (textFields.playerName.text.length > 0 && textFields.roomCode.text.length > 0);
    }
}

socket.on("join_lobby", () => {
    sm.loadScene(sm.SCENE.lobby);
});

socket.on("error_message", (_message) => {
    errorMessage = _message;
});

socket.on("check_reconnect", (_canReconnect) => {
    console.log("received");
    buttons.reconnect.enabled = _canReconnect;
});

socket.on("reconnect", (_player) => {
    playerName = _player.name;
    role = _player.role;
    inventory = prevGame.inventory;

    sm.loadScene(sm.SCENE.game);
});

img.menu.onload = function()
{
    _init();
}


export function init()
{
    if(img.menu.complete)
        _init();
}

function _init()
{
    canvas.width = img.menu.width * SCALE;
    canvas.height = img.menu.height * SCALE;

    ctx.imageSmoothingEnabled = false;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    buttons.hostGame.enabled = (textFields.playerName.text.length > 0);
    buttons.joinGame.enabled = (textFields.playerName.text.length > 0 && textFields.roomCode.text.length > 0);
    buttons.reconnect.enabled = false;

    buttons.help.interactBox.y = 15.5 * 16;  // Move up slightly
    buttons.credits.interactBox.y = 18 * 16; // Move down slightly

    canvas.addEventListener("click", onClick);
    window.addEventListener("keydown", onKeyDown);

    if(localStorage.prevGame)
    {
        prevGame = JSON.parse(localStorage.prevGame);
        roomId = prevGame.roomId;
        // socket.emit("reconnect", prevGame.roomId, prevGame.socketId);
        socket.emit("check_reconnect", prevGame.roomId, prevGame.socketId);
    }

    // buttons.reconnect.enabled = localStorage.prevGame != null;
}

export function exit()
{
    canvas.removeEventListener("click", onClick);
    window.removeEventListener("keydown", onKeyDown);
}

function drawTextField(textField)
{
    ctx.save();

    ctx.fillStyle = "white";
    ctx.fillRect(
        textField.interactBox.x * SCALE,
        textField.interactBox.y * SCALE,
        textField.interactBox.width * SCALE,
        textField.interactBox.height * SCALE);

    ctx.strokeStyle = (selectedTextField == textField) ? "dodgerblue" : "black";
    ctx.strokeRect(
        textField.interactBox.x * SCALE,
        textField.interactBox.y * SCALE,
        textField.interactBox.width * SCALE,
        textField.interactBox.height * SCALE);

    ctx.font = "20px Kenney Mini Square";
   
    ctx.textAlign = "left";

    if(textField.text == "")
    {
        ctx.fillStyle = "gray";
        ctx.fillText(textField.label,
            (textField.interactBox.x + 4) * SCALE,
            textField.interactBox.y * SCALE);
    }
    else
    {
        ctx.fillStyle = "black";
        ctx.fillText(textField.text,
            (textField.interactBox.x + 4) * SCALE,
            textField.interactBox.y * SCALE);
    }

    ctx.restore();
}

export function draw()
{
    if(sm.currentScene != sm.SCENE.menu) {
        // If we're not in the menu scene, stop the animation loop
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        return;
    }

    if(!document.fonts.check("48px Kenney Mini Square"))
    {
        animationFrameId = requestAnimationFrame(draw);
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img.menu, 0, 0, img.menu.width * SCALE, img.menu.height * SCALE);

    ctx.font = "48px Kenney Mini Square";
    ctx.fillStyle = "black";
    ctx.textBaseline = "top";
    ctx.textAlign = "center";
    ctx.fillText("It  Takes  a  Village", canvas.width / 2, 60*SCALE);

    drawTextField(textFields.playerName);
    drawTextField(textFields.roomCode);
    drawButton(buttons.hostGame);
    drawButton(buttons.joinGame);
    drawButton(buttons.reconnect);
    drawButton(buttons.help);
    drawButton(buttons.credits);

    ctx.font = "20px Kenney Mini Square";
    ctx.fillStyle = "red";
    ctx.fillText(errorMessage, 13*16*SCALE, 16.5*16*SCALE);

    ctx.fillStyle = "black";
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    ctx.fillText("v1.2", 20*SCALE, canvas.height - 20*SCALE);

    if (helpModal && helpModal.isVisible) {
        helpModal.draw(ctx);
    }

    // Request the next animation frame
    animationFrameId = requestAnimationFrame(draw);
}

================
File: client/scenes/SceneWin.js
================
import * as global from "../global.js";
Object.entries(global).forEach(([name, exported]) => window[name] = exported);

import {img} from "../assets.js";

import * as sm from "../src/SceneManager.js";
import { Button } from "../src/Button.js";

class Record
{
    constructor(name, value)
    {
        this.name = name;
        this.value = value;
    }
}

let records = [];

let game = null;


const buttons = {
    menu: new Button(16*10, 16*18, 6*16, 2*16, "red", "menu"),
}

socket.on("game", (_game) => {
    game = _game;

    records = [
        new Record("day", game.day),
        new Record("villagers remaining", game.villagers.length),
        new Record("budget remaining", game.budget),
        new Record("average happiness", game.villagers.reduce((a, b) => a + b.happiness, 0) /  game.villagers.length),
        new Record("quests completed", game.villagers.reduce((a, b) => a + (b.quest ? 0 : 1), 0)),
        new Record("most quests completed", game.players.reduce((a, b) => b.questsComplete > a.questsComplete ? b : a, game.players[0]).name),
    ];
});

function onClick(e)
{
    if(buttonClick(buttons.menu))
    {
        sm.loadScene(sm.SCENE.menu);

        players = [];
        rolesPresent = {};
        npcPresent = {};

        playerName = "";
        role = "";
        roomId = "";
        socketId = "";
        inventory = [];
    }
}

export function init()
{
    canvas.width = img.menu.width * SCALE;
    canvas.height = img.menu.height * SCALE;

    socket.emit("game", roomId);

    canvas.addEventListener("click", onClick);
}

export function exit()
{
    canvas.removeEventListener("click", onClick);
}

export function draw()
{
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "black";
    ctx.font = "48px Kenney Mini Square";
    ctx.textAlign = "center";
    ctx.fillText("you win!", canvas.width / 2, 16*3*SCALE);

    ctx.font = "20px Kenney Mini Square";

    ctx.textAlign = "left";
    for(let i = 0; i < records.length; i++)
        ctx.fillText(records[i].name, 16*4*SCALE, 16*(6+(1.5*i))*SCALE);

    ctx.textAlign = "right";
    for(let i = 0; i < records.length; i++)
        ctx.fillText(records[i].value, 16*21*SCALE, 16*(6+(1.5*i))*SCALE);

    drawButton(buttons.menu);

    if(sm.currentScene == sm.SCENE.win)
        requestAnimationFrame(draw);
}

================
File: client/src/Animation.js
================
export class Animation {

    constructor(frames, duration)     // frames: array of images, delay: duration of frame
    {
        this.frames = frames;

        this.numFrames = frames.length;
        this.currentFrame = 0;

        this.duration = duration;
        this.tick = 0;
    }

    getFrame()
    {
        this.tick++;

        if(this.tick == this.duration)
        {
            this.tick = 0;
            this.currentFrame = (this.currentFrame + 1) % this.numFrames;
        }

        return this.frames[this.currentFrame];
    }
}

================
File: client/src/Button.js
================
export class Button {
    constructor(x, y, width, height, color = "pink", text = "")
    {
        this.interactBox = { x, y, width, height };
        this.text = text;

        this.enabled = true;

        switch(color)
        {
            case "pink":
                this.colorA = "#ff66bd";
                this.colorB = "#ff7fc7";
                break;
            case "red":
                this.colorA = "#ff6666";
                this.colorB = "#ff8080";
                break;
            case "orange":
                this.colorA = "#ffa666";
                this.colorB = "#ffb580";
                break;
            case "green":
                this.colorA = "#52cc52";    // #66ff66
                this.colorB = "#5ce65c";    // #80ff80
                break;
            case "blue":
                this.colorA = "#66ccff";
                this.colorB = "#80d4ff";
                break;
            case "purple":
                this.colorA = "#9966ff";
                this.colorB = "#9999ff";
                break;
            default:
                this.colorA = "white";
                this.colorB = "black";
                break;
        }
    }
}

================
File: client/src/DayNotification.js
================
// notification for when a turn ends

import { canvas, ctx, SCALE } from "../global.js";

export class DayNotification {

    // constant
    static lifetime = 180;             // frames text is visible for
    static fadeThreshold = 30;        // life at which text starts fading

    // variable
    static text = "";
    static life = 0;

    static reset(day)                   // new day number
    {
        DayNotification.text = "day " + day;
        DayNotification.life = DayNotification.lifetime;
    }

    static draw()
    {
        if(DayNotification.life > 0)
        {
            ctx.save();

            ctx.fillStyle = "black";

            if(DayNotification.life < DayNotification.fadeThreshold)
                ctx.globalAlpha = DayNotification.life / DayNotification.fadeThreshold;

            // ctx.fillRect(16*19.5*SCALE, 16*4.5*SCALE, 16*3*SCALE, 16*1*SCALE);
            ctx.strokeStyle = "black";
            ctx.lineWidth = 16;

            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = "72px Kenney Mini Square";
            
            ctx.strokeText(DayNotification.text, canvas.width/2, 16*4*SCALE);
            ctx.fillText(DayNotification.text, canvas.width/2, 16*4*SCALE);

            ctx.restore();
            
            DayNotification.life--;
        }
    }

};

================
File: client/src/ItemStack.js
================
export class ItemStack {
    constructor(item, amount)
    {
        this.item = item;
        this.amount = amount;
    }
};

================
File: client/src/Notification.js
================
export class Notification {
    constructor(text, duration)
    {
        this.text = text;
        this.duration = duration;
    }

    draw(ctx, scale)
    {
        ctx.font = "24px Kenney Mini Square";
        ctx.fillStyle = "white";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillText(this.text, 16*21*scale, 16*11*scale);
    }
}

================
File: client/src/NotificationArrival.js
================
import { Notification } from "./Notification.js";
import { drawVillager } from "../global.js";

export class NotificationArrival extends Notification {

    // Event obj
    constructor(villager)
    {
        let text = "a villager has arrived.";
        super(text, 3500);

        this.villager = villager;
    }

    draw(ctx, scale)
    {
        ctx.font = '16px Kenney Mini Square';
        ctx.fillStyle = "lightgreen";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillText(this.text, 16*21*scale, 16*9*scale);

        drawVillager(this.villager, 16*20, 16*9.25, 2);

        ctx.fillStyle = "white";
        ctx.font = '16px Kenney Mini Square';
        ctx.fillText(this.villager.name, 16*21*scale, 16*13*scale);
    }
};

================
File: client/src/NotificationEvent.js
================
import { Notification } from "./Notification.js";

import * as global from "../global.js";
Object.entries(global).forEach(([name, exported]) => window[name] = exported);

export class NotificationEvent extends Notification {

    // Event obj
    constructor(event, image)
    {
        let text = "New event";
        super(text, 3000);

        this.image = image;
        this.description = event.blocked ? "this event has been blocked." : event.description;
        this.blocked = event.blocked;
    }

    draw(ctx, scale)
    {
        // super.draw(ctx);
        ctx.font = '16px Kenney Mini Square';
        ctx.fillStyle = "white";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillText(this.text, 16*21*scale, 16*9*scale);

        if(this.blocked)
            drawGrayscale(this.image, 16*18*scale, 16*10*scale, 16*6*scale, 16*2.5*scale);
        else
            ctx.drawImage(this.image, 16*18*scale, 16*10*scale, 16*6*scale, 16*2.5*scale);

        ctx.font = '16px Kenney Mini Square';
        ctx.fillText(this.description, 16*21*scale, 16*13*scale);
    }
};

================
File: client/src/NotificationFlee.js
================
import { Notification } from "./Notification.js";
import { drawVillager } from "../global.js";

export class NotificationFlee extends Notification {

    // Event obj
    constructor(villager)
    {
        let text = "a villager has fled.";
        super(text, 2500);

        this.villager = villager;
    }

    draw(ctx, scale)
    {
        ctx.font = '16px Kenney Mini Square';
        ctx.fillStyle = "white";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillText(this.text, 16*21*scale, 16*9*scale);

        drawVillager(this.villager, 16*20, 16*9.25, 2);

        ctx.font = '16px Kenney Mini Square';
        ctx.fillText(this.villager.name, 16*21*scale, 16*13*scale);
    }
};

================
File: client/src/NotificationQuest.js
================
import { Notification } from "./Notification.js";
import { drawVillager } from "../global.js";

export class NotificationQuest extends Notification {

    // Event obj
    constructor(villager, playerName, drawExtra)
    {
        let text = playerName + " has completed a quest!";
        super(text, 3500);

        this.villager = villager;
        this.playerName = playerName;
        this.drawExtra = drawExtra;
    }

    draw(ctx, scale)
    {
        ctx.font = '16px Kenney Mini Square';
        ctx.fillStyle = "white";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillText(this.text, 16*21*scale, 16*9*scale);

        drawVillager(this.villager, 16*20, 16*9, 2);

        ctx.font = '16px Kenney Mini Square';
        ctx.fillText(this.villager.name, 16*21*scale, 16*12.25*scale);

        ctx.fillStyle = "goldenrod";
        ctx.fillText(this.villager.quest.description, 16*21*scale, 16*13*scale);

        if(this.drawExtra)
        {
            ctx.fillStyle = "black";
            ctx.globalAlpha = 0.9;
            ctx.fillRect(16*8*scale, 16*14.5*scale, 16*26*scale, 16*2*scale);

            ctx.fillStyle = "white";
            ctx.fillText("received steel x1", 16*21*scale, 16*15.5*scale);
        }

    }
};

================
File: client/src/NotificationSeason.js
================
import { Notification } from "./Notification.js";

export class NotificationSeason extends Notification {

    constructor(season)
    {
        let text = "the season is now " + season;
        super(text, 3500);
    }

    draw(ctx, scale)
    {
        ctx.font = '24px Kenney Mini Square';
        ctx.fillStyle = "white";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillText(this.text, 16*21*scale, 16*11*scale);
    }
};

================
File: client/src/SceneManager.js
================
import * as SceneMenu from "../scenes/SceneMenu.js";
import * as SceneLobby from "../scenes/SceneLobby.js";
import * as SceneGame from "../scenes/SceneGame.js";
import * as SceneWin from "../scenes/SceneWin.js";
import * as SceneCredits from "../scenes/SceneCredits.js";

export const SCENE = {
    menu: 0,
    lobby: 1,
    game: 2,
    win: 3,
    credits: 4
};

export let currentScene = undefined;

export function loadScene(scene)
{
    if(currentScene != scene)
    {
        switch(currentScene)
        {
            case SCENE.menu:    SceneMenu.exit(); break;
            case SCENE.lobby:   SceneLobby.exit(); break;
            case SCENE.game:    SceneGame.exit(); break;
            case SCENE.win:     SceneWin.exit(); break;
            case SCENE.credits: SceneCredits.exit(); break;
            default: break;
        }

        switch(scene)
        {
            case SCENE.menu:
                SceneMenu.init();
                requestAnimationFrame(SceneMenu.draw);
                break;

            case SCENE.lobby:
                SceneLobby.init();
                requestAnimationFrame(SceneLobby.draw);
                break;
            
            case SCENE.game:
                SceneGame.init();
                requestAnimationFrame(SceneGame.draw);
                break;
            
            case SCENE.win:
                SceneWin.init();
                requestAnimationFrame(SceneWin.draw);
                break;

            case SCENE.credits:
                SceneCredits.init();
                requestAnimationFrame(SceneCredits.draw);
                break;
        }

        currentScene = scene;
    }
}

================
File: client/src/TextField.js
================
export class TextField {
    constructor(x, y, width, height, label = "", charLimit)
    {
        this.interactBox = { x, y, width, height };
        this.label = label;
        this.charLimit = charLimit;
        this.text = "";
    }
}

================
File: client/src/ToolTip.js
================
export class ToolTip{
    constructor(x, y, radius){
        this.interactBox = {x, y, width: radius, height: radius , radius};
    }
}

================
File: client/styles.css
================
body {
    margin: 0;
}

@media screen and (min-resolution: 120dpi) { 
    body {
        margin: 0;
        transform: scale(0.8);
    }
}

#canvas {
    image-rendering: crisp-edges;
    -webkit-font-smoothing : none;
}

#wrapper {
    text-align: center;
}

================
File: map/map.tmx
================
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.10" tiledversion="1.10.1" orientation="orthogonal" renderorder="right-down" width="42" height="22" tilewidth="16" tileheight="16" infinite="0" nextlayerid="7" nextobjectid="1">
 <tileset firstgid="1" source="tinytown.tsx"/>
 <tileset firstgid="133" source="roguelike.tsx"/>
 <layer id="1" name="terrain" width="42" height="22">
  <data encoding="csv">
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,13,15,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,13,14,14,14,14,14,14,15,1,25,27,1,13,14,14,14,14,14,14,15,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,25,26,26,26,26,26,26,27,1,25,27,1,25,26,26,26,26,26,26,27,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,25,26,26,26,26,26,26,27,1,25,27,1,25,26,26,26,26,26,26,27,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,37,38,38,38,38,38,38,39,1,25,27,1,37,38,38,38,38,38,38,39,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,25,27,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,13,14,14,14,14,14,14,14,14,14,40,41,14,14,14,14,14,14,14,14,14,15,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,37,38,38,38,38,38,38,38,38,38,43,42,38,38,38,38,38,38,38,38,38,39,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,25,27,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,13,14,14,14,14,14,14,15,1,25,27,1,13,14,14,14,14,14,14,15,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,25,26,26,26,26,26,26,27,1,25,27,1,25,26,26,26,26,26,26,27,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,25,26,26,26,26,26,26,27,1,25,27,1,25,26,26,26,26,26,26,27,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,37,38,38,38,38,38,38,39,1,25,27,1,37,38,38,38,38,38,38,39,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,37,39,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0
</data>
 </layer>
 <layer id="2" name="fences" width="42" height="22">
  <data encoding="csv">
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,45,46,46,46,46,46,46,46,46,47,0,0,45,46,46,46,46,46,46,46,46,47,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,69,46,46,46,83,81,46,46,46,71,0,0,69,46,46,46,83,81,46,46,46,71,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,45,46,46,46,46,46,46,46,46,47,0,0,45,46,46,46,46,46,46,46,46,47,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,59,0,0,57,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,69,46,46,46,83,81,46,46,46,71,0,0,69,46,46,46,83,81,46,46,46,71,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
</data>
 </layer>
 <layer id="4" name="shrubs" width="42" height="22">
  <data encoding="csv">
1558,1559,1559,1559,1559,1559,1559,1560,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1558,1559,1559,1559,1559,1559,1559,1560,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,97,98,99,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,109,110,111,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,121,122,123,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1615,1616,1616,1616,1616,1616,1616,1617,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,1615,1616,1616,1616,1616,1616,1616,1617,
1672,1673,1673,1673,1673,1673,1673,1674,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,1672,1673,1673,1673,1673,1673,1673,1674
</data>
 </layer>
 <layer id="5" name="ui" width="42" height="22">
  <data encoding="csv">
1599,1600,1600,1600,1600,1600,1600,1601,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1599,1600,1600,1600,1600,1600,1600,1601,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1656,1657,1657,1657,1657,1657,1657,1658,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1656,1657,1657,1657,1657,1657,1657,1658,
1713,1714,1714,1714,1714,1714,1714,1715,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1713,1714,1714,1714,1714,1714,1714,1715
</data>
 </layer>
 <layer id="6" name="apple trees" width="42" height="22">
  <data encoding="csv">
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1337,1338,1338,1338,1338,1338,1338,1338,1338,1339,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1394,1395,1395,1395,1395,1395,1395,1395,1395,1396,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1451,1452,1452,1452,1452,1452,1452,1452,1452,1453,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
</data>
 </layer>
</map>

================
File: map/menu.tmx
================
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.10" tiledversion="1.10.1" orientation="orthogonal" renderorder="right-down" width="32" height="22" tilewidth="16" tileheight="16" infinite="0" nextlayerid="7" nextobjectid="1">
 <tileset firstgid="1" source="tinytown.tsx"/>
 <tileset firstgid="133" source="roguelike.tsx"/>
 <layer id="1" name="terrain" width="32" height="22">
  <data encoding="csv">
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
</data>
 </layer>
 <layer id="4" name="shrubs" width="32" height="22">
  <data encoding="csv">
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,
6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6
</data>
 </layer>
</map>

================
File: map/roguelike.tsx
================
<?xml version="1.0" encoding="UTF-8"?>
<tileset version="1.10" tiledversion="1.10.1" name="roguelike" tilewidth="16" tileheight="16" spacing="1" tilecount="1767" columns="57">
 <image source="roguelikeSheet_transparent.png" width="968" height="526"/>
</tileset>

================
File: map/tinytown.tsx
================
<?xml version="1.0" encoding="UTF-8"?>
<tileset version="1.10" tiledversion="1.10.1" name="tinytown" tilewidth="16" tileheight="16" tilecount="132" columns="12">
 <image source="tilemap_packed.png" width="192" height="176"/>
</tileset>

================
File: Procfile
================
web: cd server && npm start

================
File: README.md
================
# It Takes a Village

## About

It Takes a Village is a collaborative multiplayer game designed and developed for the Innovative Instructional Technology Grant. The game is written in JavaScript using HTML Canvas, along with:
- **Node.js**: Runtime environment.
- **Express**: Backend server.
- **Socket.IO**: For sending messages between the client and server.

## How to Run

To run the game locally, please ensure that you have Node.js installed.  
Then navigate to the root of the repository and run the following commands:

`cd server`  
`npm install`  
`npm start`

The game will run in the browser at `localhost:8000`.

## Project Structure

The project is divided into two main folders:
- `client`
    - Contains the static HTML page.
    - Game assets (images, audio, and fonts).
    - Logic for player input and client-side rendering.
- `server`
    - Contains code for setting up the backend server.
    - Logic for creating and maintaining active games, contains the majority of game logic.
    - Communicates messages between clients.

The `map` folder contains maps and tilesheets for designing the game layout, and includes project files for the Tiled map editor. The contents in this folder are used for development only and are not loaded when the game is running.

Documentation for `client` and `server`, and instructions for deployment are available in the [wiki](https://github.com/katsuroom/ittakesavillage/wiki).

================
File: server/assets/text/names-female.txt
================
Amber
Ashley
Audrey
Avery
Bertha
Brooke
Cali
Christy
Coraline
Darlene
Delia
Edith
Everly
Fauna
Flora
Gerda
Hailey
Hilda
Ingrid
Jenny
June
Kendall
Kim
Lara
Leanne
Luna
Mary
Maxine
Milly
Nessa
Nona
Rachel
Rose
Shirly
Silvia
Stella
Summer
Tina
Victoria
Whitney

================
File: server/assets/text/names-male.txt
================
Ainsley
Alfred
Ashton
Arthur
Baxter
Bentley
Blake
Chad
Chester
Clayton
Clifford
Colton
Dale
Dexter
Dwayne
Edgar
Edison
Edward
Fred
Graham
Harlan
Harold
Harry
Hayden
Howard
Hunter
Kendrick
Kingsley
Landon
Marvin
Maxwell
Oscar
Preston
Riley
Stan
Tate
Wesley
Wilfred
Winston
William

================
File: server/db.js
================
const mongoose = require("mongoose");
const Schema = mongoose.Schema;

const GameSchema = new Schema({
    roomId: {type: String},
    playerCount: {type: Number},
    days: []
}, {timestamps: true});


const GameModel = mongoose.model("game", GameSchema);


function addNewGame(game)
{
    let model = GameModel({
        roomId: game.roomId,
        playerCount: game.players.length,
        days: []
    });

    model.save();

    addDay(game);
}

function addNewGame1(game)
{
    console.log("Room ID: " + game.roomId);
    console.log("Players: " + game.players.length);
}

function addDay1(game)
{
    let day = {
        budget: game.budget,
        event: game.event.name,
        player: {},
        villagers: [],
        facilities: [],
        actions: game.actions
    };

    day.player = {
        name: game.players[game.currentTurn].name,
        role: game.players[game.currentTurn].role
    };

    game.villagers.forEach(villager => {
        day.villagers.push({
            name: villager.name,
            sick: villager.sick,
            hunger: villager.hunger,
            happiness: villager.happiness
        });
    });

    for (let [key, value] of Object.entries(game.facilities))
    {
        day.facilities.push({
            name: key,
            level: value.level,
            progress: value.progress
        });
    }

    console.log("Room ID: " + game.roomId);
    console.log(day);

    game.actions = [];
}

async function addDay(game)
{
    let day = {
        day: game.day,
        budget: game.budget,
        event: game.event.name,
        player: {},
        villagers: [],
        facilities: [],
        // actions: game.actions
        actions: []
    };

    day.player = {
        name: game.players[game.currentTurn].name,
        role: game.players[game.currentTurn].role
    };

    game.villagers.forEach(villager => {
        day.villagers.push({
            name: villager.name,
            sick: villager.sick,
            hunger: villager.hunger,
            happiness: villager.happiness
        });
    });

    for (let [key, value] of Object.entries(game.facilities))
    {
        day.facilities.push({
            name: key,
            level: value.level,
            progress: value.progress
        });
    }

    try
    {
        let models = await GameModel.find({roomId: game.roomId});
        let model = models[0];

        if(model.days.length > 0)
            model.days[model.days.length - 1].actions = game.actions;

        model.days.push(day);

        let index = model.days.length - 1;
        model.markModified(`days.${index}`);
        model.save();
    }
    catch(err)
    {
        console.log(err);
        console.log("Room ID: " + game.roomId);
        console.log(day);
    }
    
    game.actions = [];
}

module.exports = {
    addNewGame, addDay
};

================
File: server/global.js
================
const Seed = require("./src/Seed.js");
const Food = require("./src/Food.js");
const Material = require("./src/Material.js");
const Quest = require("./src/Quest.js");
const Season = require("./src/Season.js");
const Event = require("./src/Event.js");
const {Option, RandomTable} = require("./src/RandomTable.js");
const ShopItem = require("./src/ShopItem.js");


const FARMLAND_COUNT = 32;

const TREE_COUNT = 4;
const TREE_GROWTH_TIME = 8;

const FARMLAND_UNLOCKED = false;
const FARMLAND_LOCKED = true;

const SICK_CHANCE = 0.08;
const HUNGRY_SICK_CHANCE = 0.25;
const MUTATION_FREQUENCY = 5;
const MUTATION_CHANCE = 0.50;

const DEATH_THRESHOLD = 40;
const FLOOD_DAMAGE = 20;

const MAX_VILLAGE_REPUTATION = 3;

const ITEMS = {
    cucumber: new Food("cucumber", "cucumber"),
    tomato: new Food("tomato", "tomato"),
    potato: new Food("potato", "potato"),
    carrot: new Food("carrot", "carrot"),
    apple: new Food("apple", "apple"),

    cucumberSeed: undefined,
    tomatoSeed: undefined,
    potatoSeed: undefined,
    carrotSeed: undefined,

    wood: new Material("wood", "wood", 3, 8),
    brick: new Material("brick", "brick", 4, 8),
    steel: new Material("steel", "steel", 8, 15),
};

ITEMS.cucumberSeed = new Seed("cucumber seed", "cucumber_seed", ITEMS.cucumber);
ITEMS.tomatoSeed = new Seed("tomato seed", "tomato_seed", ITEMS.tomato);
ITEMS.potatoSeed = new Seed("potato seed", "potato_seed", ITEMS.potato);
ITEMS.carrotSeed = new Seed("carrot seed", "carrot_seed", ITEMS.carrot);

const QUESTS = [
    new Quest("happiness", 70, "reach 70 happiness"),
    new Quest("happiness", 80, "reach 80 happiness"),
    new Quest("happiness", 90, "reach 90 happiness"),
];

["water", "farming", "education", "housing"].forEach(facility => {
    QUESTS.push(new Quest(facility, 2, facility + " level = 2"));
    QUESTS.push(new Quest(facility, 3, facility + " level = 3"));
    QUESTS.push(new Quest(facility, 4, facility + " level = 4"));

    QUESTS.push(new Quest("task", [facility, 5], facility + " 5 days"));
});

const SHOP = {
    "npc_doctor":       new ShopItem("doctor npc", "npc_doctor", 400, 1, "every player receives 1 free heal per day"),
    "npc_scientist":    new ShopItem("scientist npc", "npc_scientist", 400, 1, "unlocks apple trees"),
    "npc_sociologist":  new ShopItem("sociologist npc", "npc_sociologist", 400, 1, "allows every player to view villager happiness"),
    "npc_farmer":       new ShopItem("farmer npc", "npc_farmer", 400, 1, "unlocks seeds in the shop"),
    "npc_engineer":     new ShopItem("engineer npc", "npc_engineer", 400, 1, "unlocks steel in the shop"),

    "cucumber_seed":    new ShopItem("cucumber seed", "cucumber_seed", 10, -1, "one cucumber seed"),
    "tomato_seed":      new ShopItem("tomato seed", "tomato_seed", 10, -1, "one tomato seed"),
    "potato_seed":      new ShopItem("potato seed", "potato_seed", 10, -1, "one potato seed"),
    "carrot_seed":      new ShopItem("carrot seed", "carrot_seed", 10, -1, "one carrot seed"),

    "steel":            new ShopItem("steel", "steel", 30, -1, "a good building material"),
}

const SEASONS = [
    new Season("spring", 10),
    new Season("summer", 10),
    new Season("autumn", 10),
    new Season("winter", 10),
    new Season("game end", 0)
];

const EVENT_DURATION_MIN = 3;
const EVENT_DURATION_MAX = 3;

const EVENTS = {
    // neutral
    "cloudy_day": new Event("Cloudy Day", "cloudy_day", "no effect.", 0),

    // positive
    "harvest": new Event("Harvest", "harvest", "each player receives free crops.", 0),
    "rainy_day": new Event("Rainy Day", "rainy_day", "planted crops grow one day faster.", 0),
    "free_cake": new Event("Free Cake", "free_cake", "a new villager has arrived.", 0),
    "black_friday": new Event("Black Friday", "black_friday", "prices are 50% off.", 0),
    "summer_day": new Event("Summer Day", "summer_day", "villagers are temporarily immune to sickness.", 0),

    // negative
    "drought": new Event("Drought", "drought", "some crops will die each day.", 1),
    "disease": new Event("Disease", "disease", "some villagers have become ill.", 1),
    "heat_stroke": new Event("Heat Stroke", "heat_stroke", "villager progress is slowed.", 1),
    "death": new Event("Death", "death", "a villager will die if happiness is not raised.", 1),
    "flood": new Event("Flood", "flood", "all facilities lose 20 progress.", 1)
};

const EVENTS_SPRING = new RandomTable([
    new Option(EVENTS["cloudy_day"], 1),
    new Option(EVENTS["harvest"], 11),
    new Option(EVENTS["rainy_day"], 15),
    new Option(EVENTS["free_cake"], 1),
    new Option(EVENTS["black_friday"], 8),
    new Option(EVENTS["drought"], 5),
    new Option(EVENTS["disease"], 5),
    new Option(EVENTS["heat_stroke"], 8),
]);

const EVENTS_SUMMER = new RandomTable([
    new Option(EVENTS["cloudy_day"], 1),
    new Option(EVENTS["harvest"], 6),
    new Option(EVENTS["rainy_day"], 5),
    new Option(EVENTS["free_cake"], 6),
    new Option(EVENTS["black_friday"], 6),
    new Option(EVENTS["summer_day"], 15),
    new Option(EVENTS["drought"], 15),
    new Option(EVENTS["disease"], 6),
    new Option(EVENTS["heat_stroke"], 24),
    new Option(EVENTS["death"], 10),
    new Option(EVENTS["flood"], 1),
]);

const EVENTS_AUTUMN = new RandomTable([
    new Option(EVENTS["cloudy_day"], 1),
    new Option(EVENTS["harvest"], 10),
    new Option(EVENTS["rainy_day"], 10),
    new Option(EVENTS["free_cake"], 5),
    new Option(EVENTS["black_friday"], 7),
    new Option(EVENTS["drought"], 10),
    new Option(EVENTS["disease"], 15),
    new Option(EVENTS["heat_stroke"], 5),
    new Option(EVENTS["death"], 10),
    new Option(EVENTS["flood"], 10),
]);

const EVENTS_WINTER = new RandomTable([
    new Option(EVENTS["cloudy_day"], 1),
    new Option(EVENTS["free_cake"], 5),
    new Option(EVENTS["flood"], 10),
    new Option(EVENTS["drought"], 20),
    new Option(EVENTS["disease"], 30),
    new Option(EVENTS["death"], 15),
]);

const DAILY_LOOT = new RandomTable([
    new Option(ITEMS.cucumberSeed, 15),
    new Option(ITEMS.tomatoSeed, 15),
    new Option(ITEMS.potatoSeed, 15),
    new Option(ITEMS.carrotSeed, 15),
    new Option(ITEMS.cucumber, 5),
    new Option(ITEMS.tomato, 5),
    new Option(ITEMS.potato, 5),
    new Option(ITEMS.carrot, 5),
    new Option(ITEMS.brick, 20),
]);

const LOOT_AMOUNT = 2;

const SPEED_MODE_DAYS = 6;

module.exports = {
    FARMLAND_COUNT,
    FARMLAND_UNLOCKED,
    FARMLAND_LOCKED,
    SICK_CHANCE,
    HUNGRY_SICK_CHANCE,
    MUTATION_FREQUENCY,
    MUTATION_CHANCE,
    DEATH_THRESHOLD,
    FLOOD_DAMAGE,
    MAX_VILLAGE_REPUTATION,
    TREE_COUNT,
    TREE_GROWTH_TIME,
    ITEMS,
    QUESTS,
    SHOP,
    SEASONS,
    EVENT_DURATION_MIN,
    EVENT_DURATION_MAX,
    EVENTS,
    EVENTS_SPRING,
    EVENTS_SUMMER,
    EVENTS_AUTUMN,
    EVENTS_WINTER,
    DAILY_LOOT,
    LOOT_AMOUNT,
    SPEED_MODE_DAYS
};

================
File: server/package.json
================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js --watch ../client"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.6.4",
    "nodemon": "^2.0.22",
    "socket.io": "^4.7.1"
  }
}

================
File: server/src/Event.js
================
class Event {
    constructor(name, id, description = "", type = 0)
    {
        this.name = name;                   // string
        this.id = id;                       // string
        this.description = description;     // string
        this.type = type;                   // int: good = 0, bad = 1
        
        this.duration = 0;

        this.blocked = false;
    }

    clone()
    {
        return new Event(this.name, this.id, this.description);
    }

    
}

module.exports = Event;

================
File: server/src/Facility.js
================
const Interactable = require("./Interactable");

class Facility extends Interactable {
    constructor(progressMax)
    {
        super();

        this.level = 1;
        this.progress = 0;
        this.progressMax = progressMax;
        this.assignedVillagers = [];    // string array of villager names
        
        this.infoType = "facility";

        this.cost = {
            "brick": 0,
            "steel": 0
        };
    }
}

module.exports = Facility;

================
File: server/src/Farmland.js
================
const Interactable = require("./Interactable");

class Farmland extends Interactable {
    constructor(locked)
    {
        super();

        this.id = 0;
        this.crop = null;
        this.daysLeft = 0;
        this.locked = locked;
        this.fertilized = false;

        this.amount = 0;
        
        this.infoType = "farmland";
    }
}

module.exports = Farmland;

================
File: server/src/Food.js
================
const Item = require("./Item");

class Food extends Item {
    constructor(name, id)
    {
        super(name, id, "food");
    }
};

module.exports = Food;

================
File: server/src/Game.js
================
const Villager = require("./Villager.js");
const Facility = require("./Facility.js");
const Farmland = require("./Farmland.js");
const Tree = require("./Tree.js");

const global = require("../global.js");

class Game {

    static io = null;

    constructor(roomId)
    {
        // lobby info
        this.roomId = roomId;
        this.difficulty = "easy";

        this.players = [];
        this.started = false;

        this.rolesPresent = {
            "chief": false,
            "doctor": false,
            "scientist": false,
            "sociologist": false,
            "farmer": false,
            "engineer": false
        };

        this.npcPresent = {
            "doctor": false,
            "scientist": false,
            "sociologist": false,
            "farmer": false,
            "engineer": false
        };


        // game variables

        this.currentTurn = 0;

        this.day = 1;

        this.seasonIndex = 0;
        this.season = global.SEASONS[this.seasonIndex].name;
        this.nextSeason = global.SEASONS[this.seasonIndex + 1].name;
        this.daysUntilNextSeason = global.SEASONS[this.seasonIndex].days;

        this.event = null;
        this.nextEvent = null;

        this.budget = 0;

        this.villagers = [];
        this.paths = [...Array(22)].map(e => Array(26).fill('-'));
        this.mutate = false;

        this.farm = [];
        this.trees = [];

        // print if speed or regular mode
        this.difficulty = this.difficulty === 'speed' ? 'speed' : 'regular';
        console.log(`Game created with ${this.difficulty} mode.`);


        this.facilities = {
            "water": new Facility(this.difficulty === 'speed' ? 10 : 20),
            "farming": new Facility(this.difficulty === 'speed' ? 10 : 20),
            "education": new Facility(this.difficulty === 'speed' ? 10 : 20),
            "housing": new Facility(this.difficulty === 'speed' ? 10 : 20),
            "power": new Facility(this.difficulty === 'speed' ? 6 : 12)
        };

        this.actions = [];      // data collection purpose only
    }

    initPaths()
    {
        for(let i = 0; i < 26; i++)
        {
            this.paths[0][i] = 'x';
            this.paths[21][i] = 'x';
        }

        for(let i = 1; i < 22; i++)
        {
            this.paths[i][0] = 'x';
            this.paths[i][25] = 'x';
        }

        // for(let i = 2; i < 5; i++)
        // {
        //     for(let j = 9; j < 12; j++)
        //         this.paths[i][j] = 'x';
        //     for(let j = 14; j < 24; j++)
        //         this.paths[i][j] = 'x';
        // }

        for(let i = 1; i < 6; i++)
        {
            for(let j = 1; j < 25; j++)
                this.paths[i][j] = 'x';
        }
            
        for(let i = 6; i < 12; i++)
        {
            for(let j = 2; j < 12; j++)
                this.paths[i][j] = 'x';
            for(let j = 14; j < 24; j++)
                this.paths[i][j] = 'x';
        }

        for(let i = 14; i < 20; i++)
        {
            for(let j = 2; j < 12; j++)
                this.paths[i][j] = 'x';
            for(let j = 14; j < 24; j++)
                this.paths[i][j] = 'x';
        }
    }

    createVillager()    // return villager
    {
        let villager = new Villager(this.villagers, this.paths);
        this.villagers.push(villager);
        return villager;
    }

    initVillagers()
    {
        let villagerCount = this.difficulty == "easy" ? 8 : 12;

        for(let i = 0; i < villagerCount; i++)
        {
            let villager = this.createVillager();

            // assign quest
            let index = Math.floor(Math.random() * global.QUESTS.length);
            let quest = global.QUESTS[index];

            if(quest.type != "happiness")
                global.QUESTS.splice(index, 1);

            villager.quest = quest;
        }

        this.sortVillagers();

        // restore part of path
        for(let i = 1; i < 25; i++)
            this.paths[5][i] = '-';

        this.players.forEach(player => Game.io.sockets.to(player.id).emit("max_villagers", villagerCount));
    }

    sortVillagers()
    {
        // sort by y position
        this.villagers.sort(function(a, b) {
            return a.position.y - b.position.y;
        });
    }

    initFacilities()
    {
        let padding = 10;

        this.facilities["water"].label = "water";
        this.facilities["water"].interactBox = {x: 176 - padding, y: 112 - padding, width: 128 + 2 * padding, height: 64 + 2 * padding};

        this.facilities["farming"].label = "farming";
        this.facilities["farming"].interactBox = {x: 368 - padding, y: 112 - padding, width: 128 + 2 * padding, height: 64 + 2 * padding};

        this.facilities["education"].label = "education";
        this.facilities["education"].interactBox = {x: 176 - padding, y: 240 - padding, width: 128 + 2 * padding, height: 64 + 2 * padding};

        this.facilities["housing"].label = "housing";
        this.facilities["housing"].interactBox = {x: 368 - padding, y: 240 - padding, width: 128 + 2 * padding, height: 64 + 2 * padding};

        this.facilities["power"].label = "power";
        this.facilities["power"].interactBox = {x: 16*16, y: 16*2, width: 64, height: 16*3};
    }

    initBudget()
    {
        switch(this.players.length)
        {
            case 1: this.budget = 1200; break;
            case 2: this.budget = 1000; break;
            case 3: this.budget = 600; break;
            case 4: this.budget = 400; break;
            case 5: this.budget = 250; break;
            case 6: this.budget = 150; break;
            default: break;
        }
    }

    initInventory() // return array of items
    {
        let startingItems = [];

        let seeds = [global.ITEMS.cucumberSeed, global.ITEMS.tomatoSeed, global.ITEMS.potatoSeed, global.ITEMS.carrotSeed];
        let crops = [global.ITEMS.cucumber, global.ITEMS.tomato, global.ITEMS.potato, global.ITEMS.carrot];

        let numSeeds = 0;
        let numCrops = 0;

        switch(this.players.length)
        {
            case 1:
            case 2: numSeeds = 6; numCrops = 4; break;
            case 3: numSeeds = 4; numCrops = 4; break;
            case 4: numSeeds = 4; numCrops = 2; break;
            case 5: numSeeds = 3; numCrops = 2; break;
            case 6: numSeeds = 3; break;
            default: break;
        }

        for(let i = 0; i < numSeeds; i++)
        {
            let item = seeds[Math.floor(Math.random() * seeds.length)];
            startingItems.push(item);
        }

        for(let i = 0; i < numCrops; i++)
        {
            let item = crops[Math.floor(Math.random() * crops.length)];
            startingItems.push(item);
        }

        // for(let i = 0; i < 12; ++i)
        //     startingItems.push(global.ITEMS.steel);
        // startingItems.push(global.ITEMS.brick);
        // startingItems.push(global.ITEMS.brick);
        // startingItems.push(global.ITEMS.brick);
        // startingItems.push(global.ITEMS.brick);

        return startingItems;
    }

    initFarmland()
    {
        let startingAmount = 8;

        for(let i = 0; i < global.FARMLAND_COUNT; i++)
        {
            let farmland = new Farmland(i < startingAmount ? global.FARMLAND_UNLOCKED : global.FARMLAND_LOCKED);
            farmland.interactBox = {
                x: 16 * (i % 8 + 23),
                y: 16 * (Math.floor(i / 8) + 7),
                width: 16,
                height: 16
            }
            farmland.label = "empty";
            farmland.id = i;
            farmland.amount = 2;
            this.farm.push(farmland);
        }

        this.updateFarmlandAmount();
    }

    initTrees()
    {
        for(let i = 0; i < global.TREE_COUNT; i++)
        {
            let tree = new Tree();

            tree.id = i;

            this.trees.push(tree);
        }
    }

    initEvent()
    {
        this.event = global.EVENTS["cloudy_day"];
        this.event.duration = 3;
        // faster event changes for speed mode
        if(this.difficulty === 'speed'){
            this.event.duration = 2;
        }
        this.nextEvent = this.getNextEvent();
    }


    // actions

    pickTree(treeId)
    {
        let tree = this.trees.find(tree => tree.id == treeId);
        tree.daysLeft = global.TREE_GROWTH_TIME;
    }

    cutTree(treeId)
    {
        let tree = this.trees.find(tree => tree.id == treeId);
        tree.daysLeft = 0;
        tree.cut = true;
    }

    upgradeFacility(facility)
    {
        if(facility.label == "power")
        {
            facility.level++;
            return;
        }

        facility.progress = 0;
        facility.level++;


        if(this.difficulty !== 'speed') {
            switch(facility.level)
            {
                case 2:
                    facility.progressMax = 30;
                    break;
                case 3:
                    facility.progressMax = 40;
                    break;
                case 4:
                    facility.progressMax = 60;
                    break;
                case 5:
                    break;
                default:
                    break;
            }
        } 
        // Speed mode progression - half the values and max level 3
        else {
            switch(facility.level)
            {
                case 2:
                    facility.progressMax = 15; 
                    break;
                case 3:
                    facility.progressMax = 20;
                    break;
                default:
                    break;
            }
        }
        
        // For water facility, unlock farmland
        if(facility.label == "water" && facility.level < (this.difficulty === 'speed' ? 3 : 5)){
            // In speed mode, unlock more farmland per level (16 instead of 8)
            const farmsPerLevel = this.difficulty === 'speed' ? 16 : 8;
            for(let i = 0; i < farmsPerLevel; i++) {
                const index = (facility.level - 1) * farmsPerLevel + i;
                if(index < this.farm.length) {
                    this.farm[index].locked = false;
                }
            }
        }
    
        if(facility.label == "farming")
            this.updateFarmlandAmount();
    
        this.actions.push(`Upgraded ${facility.label} to level ${facility.level}.`);
    }
    

    // calculations

    addProgress(facility, amount)
    {
        facility.progress += amount;
        if(facility.progress > facility.progressMax)
            facility.progress = facility.progressMax;
    }

    updateFacilityProgress()
    {
        // if(this.facilities["power"].assignedVillagers.length == 0)
        //     return;

        this.villagers.forEach(villager => {
            
            if(!villager.currentTask) return;

            if(villager.currentTask == "power") return;

            if(this.facilities[villager.currentTask].level >= 5) return;

            let baseProgress = 2;

            if(this.facilities["power"].assignedVillagers.length > 0)
                baseProgress = 3;

            let leastEffectiveMult, mostEffectiveMult = 0;

            if(this.difficulty === 'speed') {
                // Speed mode - better multipliers at lower levels
                switch(this.facilities["education"].level)
                {
                    case 1:
                        leastEffectiveMult = 0.9;
                        mostEffectiveMult = 1.75;
                        break;
                    case 2:
                        leastEffectiveMult = 1.25;
                        mostEffectiveMult = 2.25;
                        break;
                    case 3:
                        leastEffectiveMult = 1.5;
                        mostEffectiveMult = 2.5;
                        break;
                    default:
                        break;
                }
            } else {
                // Regular mode
                switch(this.facilities["education"].level)
                {
                    case 1:
                        leastEffectiveMult = 0.75;
                        mostEffectiveMult = 1.25;
                        break;
                    case 2:
                        leastEffectiveMult = 0.9;
                        mostEffectiveMult = 1.5;
                        break;
                    case 3:
                        leastEffectiveMult = 1;
                        mostEffectiveMult = 1.75;
                        break;
                    case 4:
                        leastEffectiveMult = 1.25;
                        mostEffectiveMult = 2;
                        break;
                    case 5:
                        leastEffectiveMult = 1.5;
                        mostEffectiveMult = 2.5;
                        break;
                    default:
                        break;
                }
            }            

            let totalProgress = 0;

            if(villager.currentTask == villager.mostEffectiveTask)
                totalProgress = baseProgress * mostEffectiveMult;

            else if(villager.currentTask == villager.leastEffectiveTask)
                totalProgress = baseProgress * leastEffectiveMult;

            else
                totalProgress = baseProgress;

            if(this.event.id == "heat_stroke")
            {
                switch(this.facilities["education"].level)
                {
                    case 1: totalProgress *= 0.75; break;
                    case 2: totalProgress *= 0.8; break;
                    case 3: totalProgress *= 0.85; break;
                    case 4: totalProgress *= 0.9; break;
                    case 5: totalProgress *= 1; break;
                    default: break;
                }
            }
            
            this.addProgress(this.facilities[villager.currentTask], totalProgress);

        });
    }

    advanceCropGrowth(amount)
    {
        this.farm.forEach((farmland) => {
            if(farmland.daysLeft > 0)
            {
                farmland.daysLeft -= amount;
                if(farmland.daysLeft <= 0)
                {
                    farmland.daysLeft = 0;
                    farmland.label = "ready";
                }
                else
                    farmland.label = farmland.daysLeft + (farmland.daysLeft > 1 ? " days" : " day");
            }
        });

        this.trees.forEach((tree) => {
            if(tree.daysLeft > 0)
            {
                tree.daysLeft -= amount;
                if(tree.daysLeft < 0)
                    tree.daysLeft = 0;
            }
        });
    }

    updateFarmlandAmount()
    {
        this.farm.forEach(farmland => {
            if(this.difficulty === 'speed') {
                // Speed mode - better yields at lower levels
                switch(this.facilities["farming"].level)
                {
                    case 1: farmland.amount = 3; break;
                    case 2: farmland.amount = 5; break;
                    case 3: farmland.amount = 8; break;
                    default: break;
                }
            } else {
                // Regular mode
                switch(this.facilities["farming"].level)
                {
                    case 1: farmland.amount = 2; break;
                    case 2: farmland.amount = 3; break;
                    case 3: farmland.amount = 4; break;
                    case 4: farmland.amount = 5; break;
                    case 5: farmland.amount = 8; break;
                    default: break;
                }
            }
        });
    }

    updateVillagers()
    {
        this.villagers.forEach(villager => {
            
            // update happiness based on hunger, except for day 1
            if(this.day > 1)
            {
                if(villager.hunger == 5)
                    villager.happiness += 5;
                else if(villager.hunger == 2 || villager.hunger == 1)
                    villager.happiness -= 5;
                else if(villager.hunger == 0)
                    villager.happiness -= 10;

                // if not fed
                if(!villager.fed)
                    villager.happiness -= (5 - this.facilities["housing"].level + 1);
            }

            // update happiness based on sickness
            if(villager.sick)
                villager.happiness -= 10;

            // update happiness based on task
            if(villager.currentTask == villager.mostFavoriteTask)
                villager.happiness += 2;
            else if(villager.currentTask == villager.leastFavoriteTask)
                villager.happiness -= 5;

            if(villager.happiness > 100)
                villager.happiness = 100;

            if(villager.quest && villager.quest.type == "task" && villager.currentTask == villager.quest.targetValue[0])
                villager.quest.targetValue[1] -= 1;

            // subtract hunger
            if(villager.hunger > 0) villager.hunger--;

            villager.fed = false;

            // chance of sickness
            if(!villager.immune && global.SICK_CHANCE > 0)
            {
                let sick = false;
                if(villager.hunger == 0)
                    sick = Math.random() < global.HUNGRY_SICK_CHANCE;
                else
                    sick = Math.random() < global.SICK_CHANCE;

                if(sick)
                {
                    this.villagerSick(villager);
                }
            }
        });
    }

    mutateVillagers()
    {
        if(this.day != 1 && this.day % global.MUTATION_FREQUENCY == 1)
        {
            this.mutate = true;

            this.villagers.forEach(villager => {
                if(Math.random() < global.MUTATION_CHANCE)
                {
                    villager.mostEffectiveTask = Villager.generateTask();
                    villager.leastEffectiveTask = Villager.generateLeastEffectiveTask(villager.mostEffectiveTask);
                }

                if(Math.random() < global.MUTATION_CHANCE)
                {
                    villager.mostFavoriteTask = Villager.generateTask();
                    villager.leastFavoriteTask = Villager.generateLeastFavoriteTask(villager.mostFavoriteTask);
                }

                if(Math.random() < global.MUTATION_CHANCE)
                {
                    villager.favoriteFood = Villager.generateFavoriteFood();
                }

                if(villager.leastEffectiveTask == "")
                    villager.leastEffectiveTask = Villager.generateLeastEffectiveTask(villager.mostEffectiveTask);

                if(villager.leastFavoriteTask == "")
                    villager.leastFavoriteTask = Villager.generateLeastFavoriteTask(villager.mostFavoriteTask);

                villager.immune = false;
            });
        }
    }

    checkQuest()
    {
        this.villagers.forEach(villager => {
            if(villager.quest)
            {
                let completed = false;

                switch(villager.quest.type)
                {
                    case "happiness":
                        completed = villager.happiness >= villager.quest.targetValue;
                        break;
                    case "task":
                        completed = villager.quest.targetValue[1] == 0;
                        break;
                    case "water":
                    case "farming":
                    case "education":
                    case "housing":
                        completed = this.facilities[villager.quest.type].level >= villager.quest.targetValue;
                        break;
                    default:
                        break;
                }

                if(completed)
                {
                    let currentPlayer = this.players[this.currentTurn];
                    currentPlayer.questsComplete++;

                    Game.io.sockets.to(currentPlayer.id).emit("give_item", global.ITEMS.steel, 1);
                    this.players.forEach(player => Game.io.sockets.to(player.id).emit("quest_complete", villager, currentPlayer.name));
                    villager.quest = null;
                    this.players.forEach(player => Game.io.sockets.to(player.id).emit("villager", villager));
                }
            }
        });
    }

    changeTurn()
    {
        this.currentTurn = (this.currentTurn + 1) % this.players.length;
        if(!this.players[this.currentTurn].connected)
            this.changeTurn();
    }

    removeVillagerFromFacility(villager)
    {
        if(villager.currentTask)
        {
            let oldFacility = this.facilities[villager.currentTask];

            for(let i = 0; i < oldFacility.assignedVillagers.length; i++)
            {
                if(oldFacility.assignedVillagers[i] == villager.name)
                {
                    oldFacility.assignedVillagers.splice(i, 1);
                    break;
                }
            }
        }
    }

    villagerFlee(villager)
    {
        this.paths[villager.position.y][villager.position.x] = "-";
    }

    villagerSick(villager)
    {
        villager.sick = true;
    }

    villagerHeal(villager)
    {
        villager.sick = false;
    }

    eventStart(event)
    {
        if(event.blocked)
            return;

        switch(event.id)
        {
            case "harvest":
                {
                    let numCrops = Math.floor(9 - this.players.length * 0.5);
                    let crops = [global.ITEMS.cucumber, global.ITEMS.tomato, global.ITEMS.potato, global.ITEMS.carrot];

                    this.players.forEach(player => {
                        for(let i = 0; i < numCrops; i++)
                        {
                            let item = crops[Math.floor(Math.random() * crops.length)];
                            Game.io.sockets.to(player.id).emit("give_item", item, 1);
                        }
                    });
                    
                    break;
                }
            case "rainy_day":
                {
                    this.advanceCropGrowth(1);
                    this.players.forEach(player => {
                        Game.io.sockets.to(player.id).emit("set_variable", "cropGrowthModifier", -1);
                    });
                    break;
                }
            case "free_cake":
                {
                    this.createVillager();
                    this.sortVillagers();
                    break;
                }
            case "black_friday":
                {
                    this.players.forEach(player => {
                        Game.io.sockets.to(player.id).emit("set_variable", "priceMultiplier", 0.5);
                    });
                    break;
                }
            case "summer_day":
                {
                    global.SICK_CHANCE *= -1;
                    this.villagers.forEach(villager => this.villagerHeal(villager));
                    break;
                }
            case "drought":
                {
                    this.eventUpdate(event);
                    break;
                }
            case "disease":
                {
                    let diseaseChance = 0;
                    if(this.difficulty === 'speed') {
                        switch(this.facilities["water"].level)
                        {
                            case 1: diseaseChance = 0.15; break;
                            case 2: diseaseChance = 0.05; break;
                            case 3: diseaseChance = 0; break;
                            default: break;
                        }
                    } else {
                        switch(this.facilities["water"].level)
                        {
                            case 1: diseaseChance = 0.2; break;
                            case 2: diseaseChance = 0.15; break;
                            case 3: diseaseChance = 0.1; break;
                            case 4: diseaseChance = 0.05; break;
                            case 5: diseaseChance = 0; break;
                            default: break;
                        }
                    }
                }
            case "flood":
                {
                    Object.values(this.facilities).forEach(facility => {
                        facility.progress -= global.FLOOD_DAMAGE;
                        if(facility.progress < 0)
                            facility.progress = 0;
                    });
                }
            case "death":
                {
                    let index = Math.floor(Math.random() * this.villagers.length);
                    let villager = this.villagers[index];
                    this.removeVillagerFromFacility(villager);

                    this.villagers.splice(index, 1);
                    this.villagerFlee(villager);

                    this.players.forEach(player => {
                        Game.io.sockets.to(player.id).emit("villager_flee", villager);
                        Game.io.sockets.to(player.id).emit("paths", this.paths);
                    });
                    break;
                }
            default: break;
        }
    }

    eventUpdate(event)
    {
        // console.log("update");
        // for events that have effects every day while action
        if(event.blocked)
            return;

        switch(event.id)
        {
            case "drought":
                {
                    let droughtChance = 0;
                    if(this.difficulty === 'speed') {
                        switch(this.facilities["water"].level)
                        {
                            case 1: droughtChance = 0.45; break;
                            case 2: droughtChance = 0.2; break;
                            case 3: droughtChance = 0; break;
                            default: break;
                        }
                    } else {
                        switch(this.facilities["water"].level)
                        {
                            case 1: droughtChance = 0.6; break;
                            case 2: droughtChance = 0.45; break;
                            case 3: droughtChance = 0.3; break;
                            case 4: droughtChance = 0.15; break;
                            case 5: droughtChance = 0; break;
                            default: break;
                        }
                    }
                }
            default: break;
        }
    }

    eventEnd(event)
    {
        if(event.blocked)
            return;

        switch(event.id)
        {
            case "rainy_day":
                {
                    this.players.forEach(player => {
                        Game.io.sockets.to(player.id).emit("set_variable", "cropGrowthModifier", 0);
                    });
                    break;
                }
            case "black_friday":
                {
                    this.players.forEach(player => {
                        Game.io.sockets.to(player.id).emit("set_variable", "priceMultiplier", 1);
                    });
                    break;
                }
            case "summer_day":
                {
                    global.SICK_CHANCE *= -1;
                    break;
                }
            default: break;
        }
    }

    updateEvent()
    {
        this.event.duration--;

        if(this.event.duration == 0)
        {
            this.eventEnd(this.event);

            // switch to next event
            
            if(this.facilities["power"].level > 1)
            {
                this.event = this.nextEvent;
                // let duration = this.nextEvent.duration;
                // this.event = global.EVENTS.cloudy_day.clone();
                this.event.blocked = true;
                // this.event.duration = duration;

                this.facilities["power"].level = 1;
                this.facilities["power"].progress = 0;
            }
            else
                this.event = this.nextEvent;

            this.eventStart(this.event);

            // set next event
            this.nextEvent = this.getNextEvent();
        }
        else
            this.eventUpdate(this.event);
    }

    getNextEvent()
    {
        // if on hard difficulty, use Winter event table
        if(this.difficulty == "hard")
        {
            let event = global.EVENTS_WINTER.getItem();
            return event;
        }

        // calculate season for next event
        let dayCount = this.day + this.event.duration;

        if(dayCount > 40) return null;

        let season = "";

        for(let i = 0; i < global.SEASONS.length; i++)
        {
            dayCount -= global.SEASONS[i].days;
            if(dayCount <= 0)
            {
                season = global.SEASONS[i].name;
                break;
            }
        }

        // get event from event table
        let event = null;

        while(true)
        {
            switch(season)
            {
                case "spring":
                    event = global.EVENTS_SPRING.getItem();
                    break;
                case "summer":
                    event = global.EVENTS_SUMMER.getItem();
                    break;
                case "autumn":
                    event = global.EVENTS_AUTUMN.getItem();
                    break;
                case "winter":
                    event = global.EVENTS_WINTER.getItem();
                    break;
                default:
                    break;
            }

            if(event.id != "death")
                break;
            else
            {
                // prevents consecutive death events
                if(this.event.id != "death")
                    break;
            }
        }

        event.duration = Math.floor(Math.random() * (global.EVENT_DURATION_MAX - global.EVENT_DURATION_MIN + 1))
            + global.EVENT_DURATION_MIN;
        return event;
    }

    updateSeason()
    {
        if(this.daysUntilNextSeason == 0)
        {
            for(let i = 0; i < global.SEASONS.length; i++)
            {
                if(global.SEASONS[i].name == this.season)
                {
                    if(i < global.SEASONS.length - 1)
                    {
                        this.season = global.SEASONS[i+1].name;
                        // when season ends if the game mode is speed mode then we keep 6 days per season
                        this.daysUntilNextSeason = this.difficulty === 'speed' ? global.SPEED_MODE_DAYS : global.SEASONS[i+1].days;
                    }
                    if(i < global.SEASONS.length - 2)
                        this.nextSeason = global.SEASONS[i+2].name;
                    
                    break;
                }
            }
        }
    }

    nextDay()
    {
        this.advanceCropGrowth(1);
        this.updateVillagers();
        this.updateFacilityProgress();

        // increment day
        this.day++;
        this.daysUntilNextSeason--;

        this.mutateVillagers();
        this.updateSeason();

        // check for happiness quest completion
        this.checkQuest();

        this.updateEvent();
    }

    changeSeasonDays(numDays){
        this.daysUntilNextSeason = numDays
    }
};

module.exports = Game;

================
File: server/src/Interactable.js
================
class Interactable {

    constructor()
    {
        this.label = "";
        this.infoType = "";
        this.interactBox = { 
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
    }
}

module.exports = Interactable;

================
File: server/src/Item.js
================
class Item {
    constructor(name, id, type)
    {
        this.name = name;
        this.id = id;
        this.type = type;
    }
}

module.exports = Item;

================
File: server/src/ItemStack.js
================
class ItemStack {
    constructor(item, amount)
    {
        this.item = item;
        this.amount = amount;
    }
};

module.exports = ItemStack;

================
File: server/src/Material.js
================
const Item = require("./Item");

class Material extends Item {
    constructor(name, id, progress, upgradedProgress)
    {
        super(name, id, "material");

        this.progress = progress;
        this.upgradedProgress = upgradedProgress;
        this.upgraded = false;
    }

    clone()
    {
        return new Material(this.name, this.id, this.progress, this.upgradedProgress);
    }
};

module.exports = Material;

================
File: server/src/Player.js
================
class Player {
    constructor(name, id)
    {
        this.name = name;
        this.id = id;

        this.role = "";
        this.ready = false;
        this.connected = false;

        this.questsComplete = 0;
    }
};

module.exports = Player;

================
File: server/src/Quest.js
================
class Quest {
    
    constructor(type, targetValue, description)
    {
        this.type = type;
        this.targetValue = targetValue;
        this.description = description;
    }
}

module.exports = Quest;

================
File: server/src/RandomTable.js
================
class Option {
    constructor(data, weight)
    {
        this.data = data;
        this.weight = weight;
    }
}

class RandomTable {
    constructor(options)    // options: Option[]
    {
        this.options = options;

        this.total = this.options.reduce((acc, option) => acc + option.weight, 0);
    }

    getItem()
    {
        let rand = Math.floor(Math.random() * (this.total));

        for(let i = 0; i < this.options.length; i++)
        {
            rand -= this.options[i].weight;

            if(rand < 0)
            {
                let obj = {};
                for (const key in this.options[i].data)
                    obj[key] = this.options[i].data[key];

                return obj;
            }
        }

        return null;
    }
}

module.exports = {Option, RandomTable};

================
File: server/src/Season.js
================
class Season {
    constructor(name, days)
    {
        this.name = name;
        this.days = days;
    }

    setDays(days){
        this.days = days;
    }
};

module.exports = Season;

================
File: server/src/Seed.js
================
const Item = require("./Item");

class Seed extends Item {
    constructor(name, id, food)
    {
        super(name, id, "seed");

        this.food = food;
    }
};

module.exports = Seed;

================
File: server/src/ShopItem.js
================
const Interactable = require("./Interactable");

class ShopItem extends Interactable {
    constructor(name, id, price, stock, description)
    {
        super();

        this.name = name;       // string
        this.id = id;           // string
        this.price = price;     // int
        this.stock = stock;     // int, -1 if unlimited stock
        this.description = description // string
    }
}

module.exports = ShopItem;

================
File: server/src/Tree.js
================
const Interactable = require("./Interactable");

class Tree extends Interactable {
    constructor()
    {
        super();

        this.id = 0;

        this.daysLeft = 0;
        this.cut = false;
        this.fertilized = false;
        
        this.infoType = "tree";
    }
}

module.exports = Tree;

================
File: server/src/Villager.js
================
const fs = require("fs");

const Interactable = require("./Interactable.js");

const facilities = ["water", "farming", "education", "housing"];
const foods = ["cucumber", "tomato", "potato", "carrot"];

class Villager extends Interactable {

    // villagers = array of Villagers
    constructor(villagers, paths)
    {
        super();

        this.gender = this.generateGender();
        this.name = this.generateName(villagers);

        this.shirtColor = this.generateShirtColor();
        this.hairColor = this.generateHairColor();
        this.hairStyle = this.generateHairStyle();

        this.position = this.generatePosition(paths);
        this.label = this.name;
        this.infoType = "villager";
        this.interactBox.x = this.position.x * 16 + 128;
        this.interactBox.y = this.position.y * 16;
        this.interactBox.width = 16;
        this.interactBox.height = 16;

        this.sick = false;
        this.happiness = 50;    // 0 - 100
        this.hunger = 5;        // 0 - 5
        this.favoriteFood = Villager.generateFavoriteFood();
        this.mostEffectiveTask = Villager.generateTask();
        this.leastEffectiveTask = Villager.generateLeastEffectiveTask(this.mostEffectiveTask);
        this.mostFavoriteTask = Villager.generateTask();
        this.leastFavoriteTask = Villager.generateLeastFavoriteTask(this.mostFavoriteTask);
        this.currentTask = null;

        this.quest = null;

        this.fed = false;

        this.immune = false;
    }

    generateGender()            // char
    {
        return Math.random() > 0.5 ? 'm' : 'f';
    }

    generateName(villagers)     // string
    {
        let filename;

        if(this.gender == 'm')
            filename = "assets/text/names-male.txt";
        else
            filename = "assets/text/names-female.txt";

        const data = fs.readFileSync(filename, { encoding: 'utf8', flag: 'r' });
        let lines = data.toString().split("\n");

        let name = lines[Math.floor(Math.random() * lines.length)];

        // search for duplicate name
        for(let i = 0; i < villagers.length; i++)
        {
            if(name == villagers[i].name)
            {
                name = lines[Math.floor(Math.random() * lines.length)];
                i = -1;
            }
        }

        return name;
    }

    generateShirtColor()            // {r, g, b}
    {
        let r = Math.floor(Math.random() * 256);
        let g = Math.floor(Math.random() * 256);
        let b = Math.floor(Math.random() * 256);
        return {r, g, b};
    }

    generateHairColor()             // {r, g, b}
    {
        let r = Math.floor(Math.random() * 256);
        let g = r * 0.75;
        let b = 0;
        return {r, g, b};
    }

    generateHairStyle()
    {
        let numHairStyles = 11;
        return Math.floor(Math.random() * numHairStyles);
    }

    generatePosition(paths)         // {x, y}
    {
        let x = 0;
        let y = 0;

        while(paths[y][x] == 'x')
        {
            x = Math.floor(Math.random() * 26);
            y = Math.floor(Math.random() * 22);
        }
        paths[y][x] = 'x';

        return {x: x, y: y};
    }

    static generateFavoriteFood()          // string
    {
        return foods[Math.floor(Math.random() * foods.length)];
    }

    static generateTask()                  // string
    {
        return facilities[Math.floor(Math.random() * facilities.length)];
    }

    static generateLeastEffectiveTask(mostEffectiveTask)    // string
    {
        let available = [];
        facilities.forEach(e => {
            if(e != mostEffectiveTask)
                available.push(e);
        });

        return available[Math.floor(Math.random() * available.length)];
    }

    static generateLeastFavoriteTask(mostFavoriteTask)     // string
    {
        let available = [];
        facilities.forEach(e => {
            if(e != mostFavoriteTask)
                available.push(e);
        });

        return available[Math.floor(Math.random() * available.length)];
    }
}

module.exports = Villager;
